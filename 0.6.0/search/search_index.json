{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shopify Python Library - SPyLib The Shopify python library, or SPyLib, simplifies the use of the Shopify services such as the REST and GraphQL APIs as well as the OAuth authentication. All of this is done asynchronously using asyncio . Installation pip install spylib What can SPyLib do? Official documentation Shopify components managed by SPyLib: Admin API Install an app through OAuth Session tokens Webhooks","title":"Home"},{"location":"#shopify-python-library-spylib","text":"The Shopify python library, or SPyLib, simplifies the use of the Shopify services such as the REST and GraphQL APIs as well as the OAuth authentication. All of this is done asynchronously using asyncio .","title":"Shopify Python Library - SPyLib"},{"location":"#installation","text":"pip install spylib","title":"Installation"},{"location":"#what-can-spylib-do","text":"Official documentation Shopify components managed by SPyLib: Admin API Install an app through OAuth Session tokens Webhooks","title":"What can SPyLib do?"},{"location":"admin-api/","text":"Admin API Token The token class contains the majority of the logic for communicating with shopify. To use the token class, you must define a child class for the tokens you are using and implement a subset of the save and load abstract methods. Your option for child classes are OnlineTokenABC , OfflineTokenABC or PrivateTokenABC : Implement Token Classes class OfflineToken ( OfflineTokenABC ): async def save ( self ): # Some code to save the token to a database @classmethod async def load ( cls , store_name : str ): # Some code to load the token from the database class OnlineToken ( OnlineTokenABC ): async def save ( self ): # Some code to save the token to a database @classmethod async def load ( cls , store_name : str , user_id : str ): # Some code to load the token from the database class PrivateToken ( PrivateTokenABC ): @classmethod async def load ( cls , store_name : str , user_id : str ): # Some code to load the token from the database # No need for save, as it is static. Change Shopify API version As shown in the Implement Token Classes , token can be used as following: from spylib import OfflineTokenABC class OfflineToken ( OfflineTokenABC ): async def save ( self ): pass @classmethod async def load ( cls , store_name : str ): pass If the Shopify API version used in Spylib is not the desired version, it can be changed with the following: class OfflineToken ( OfflineTokenABC ): async def save ( self ): pass @classmethod async def load ( cls , store_name : str ): pass # Add the version to be used here OfflineToken . api_version : '2022-01' Create Token Once you have defined these methods, we can create an instance of a token using one of the following: token = OfflineToken ( store_name , access_token , scope ) token = OnlineToken ( store_name , access_token , scope , expires_in , associated_user_scope , associated_user_id ) token = PrivateToken ( store_name , access_token , scope ) Querying Shopify REST We can query the store using the REST endpoint: await token . execute_rest ( request : Request , endpoint : str , json : Optional [ Dict [ str , Any ]], debug : Optional [ str ], ) For example, if you want to query a product from shopify you can run: product_json = await token . execute_rest ( request = GET , endpoint = f '/products/ { product_id } .json' ) If you want to update a product in a shop you can run: product_json = await token . execute_rest ( request = PUT , endpoint = f '/products/ { product_id } .json' , json = { \"product\" : { \"id\" : product_id , \"title\" : \"New Title\" } } ) The REST method takes a request parameter which is one of the Request constants defined in the rest file. The options are GET , POST , PUT , or DELETE . Endpoint is the API endpoint string that we are querying, this should be similar to the following format: f '/ { resource } .json?fields= { resource . param } & { [ params ] } ' The debug parameter is the message that is returned when there is an error. It is optional as it defaults to \"\" . GraphQL We can also query Shopify using the GraphQL endpoint: token . execute_gql ( query : str , variables : Dict [ str , Any ], operation_name : Optional [ str ] ) For example, if you want to query a product from shopify you can run: query = \"\"\" { product(id: \"gid://shopify/Product/1974208299030\") { id, title } }\"\"\" product_json = await token . execute_gql ( query = query ) If you want to update a product in a shop you can run: query = \"\"\" mutation productUpdateMutation($id: ID, $title: String) { productUpdate(input: { id: $id, title: $title }) { product { id } } }\"\"\" variables = { 'id' : 'gid://shopify/Product/108828309' , 'title' : \"Sweet new product - GraphQL Edition\" } product_json = await token . execute_gql ( query = query , variables = variables ) The query is a GraphQL query that will be passed to shopify for execution. You can use the GQL explorer for your shop to create a query. For example, the shopify demo GQL explorer . The variables are a dictionary of variables that will be substituted into the query. The operation_name is a name for the query you are about to run.","title":"Admin API"},{"location":"admin-api/#admin-api","text":"","title":"Admin API"},{"location":"admin-api/#token","text":"The token class contains the majority of the logic for communicating with shopify. To use the token class, you must define a child class for the tokens you are using and implement a subset of the save and load abstract methods. Your option for child classes are OnlineTokenABC , OfflineTokenABC or PrivateTokenABC :","title":"Token"},{"location":"admin-api/#implement-token-classes","text":"class OfflineToken ( OfflineTokenABC ): async def save ( self ): # Some code to save the token to a database @classmethod async def load ( cls , store_name : str ): # Some code to load the token from the database class OnlineToken ( OnlineTokenABC ): async def save ( self ): # Some code to save the token to a database @classmethod async def load ( cls , store_name : str , user_id : str ): # Some code to load the token from the database class PrivateToken ( PrivateTokenABC ): @classmethod async def load ( cls , store_name : str , user_id : str ): # Some code to load the token from the database # No need for save, as it is static.","title":"Implement Token Classes"},{"location":"admin-api/#change-shopify-api-version","text":"As shown in the Implement Token Classes , token can be used as following: from spylib import OfflineTokenABC class OfflineToken ( OfflineTokenABC ): async def save ( self ): pass @classmethod async def load ( cls , store_name : str ): pass If the Shopify API version used in Spylib is not the desired version, it can be changed with the following: class OfflineToken ( OfflineTokenABC ): async def save ( self ): pass @classmethod async def load ( cls , store_name : str ): pass # Add the version to be used here OfflineToken . api_version : '2022-01'","title":"Change Shopify API version"},{"location":"admin-api/#create-token","text":"Once you have defined these methods, we can create an instance of a token using one of the following: token = OfflineToken ( store_name , access_token , scope ) token = OnlineToken ( store_name , access_token , scope , expires_in , associated_user_scope , associated_user_id ) token = PrivateToken ( store_name , access_token , scope )","title":"Create Token"},{"location":"admin-api/#querying-shopify","text":"","title":"Querying Shopify"},{"location":"admin-api/#rest","text":"We can query the store using the REST endpoint: await token . execute_rest ( request : Request , endpoint : str , json : Optional [ Dict [ str , Any ]], debug : Optional [ str ], ) For example, if you want to query a product from shopify you can run: product_json = await token . execute_rest ( request = GET , endpoint = f '/products/ { product_id } .json' ) If you want to update a product in a shop you can run: product_json = await token . execute_rest ( request = PUT , endpoint = f '/products/ { product_id } .json' , json = { \"product\" : { \"id\" : product_id , \"title\" : \"New Title\" } } ) The REST method takes a request parameter which is one of the Request constants defined in the rest file. The options are GET , POST , PUT , or DELETE . Endpoint is the API endpoint string that we are querying, this should be similar to the following format: f '/ { resource } .json?fields= { resource . param } & { [ params ] } ' The debug parameter is the message that is returned when there is an error. It is optional as it defaults to \"\" .","title":"REST"},{"location":"admin-api/#graphql","text":"We can also query Shopify using the GraphQL endpoint: token . execute_gql ( query : str , variables : Dict [ str , Any ], operation_name : Optional [ str ] ) For example, if you want to query a product from shopify you can run: query = \"\"\" { product(id: \"gid://shopify/Product/1974208299030\") { id, title } }\"\"\" product_json = await token . execute_gql ( query = query ) If you want to update a product in a shop you can run: query = \"\"\" mutation productUpdateMutation($id: ID, $title: String) { productUpdate(input: { id: $id, title: $title }) { product { id } } }\"\"\" variables = { 'id' : 'gid://shopify/Product/108828309' , 'title' : \"Sweet new product - GraphQL Edition\" } product_json = await token . execute_gql ( query = query , variables = variables ) The query is a GraphQL query that will be passed to shopify for execution. You can use the GQL explorer for your shop to create a query. For example, the shopify demo GQL explorer . The variables are a dictionary of variables that will be substituted into the query. The operation_name is a name for the query you are about to run.","title":"GraphQL"},{"location":"development-contributing/","text":"Development - Contributing Contributing If you want to contribute a small change/feature, the best is to just create a PR with your changes. For bigger changes/features it's best to open an issue first and discuss it to agree on the code organization and overall implementation before spending too much time on the code, unless you want to keep it in your own forked repo. Setting up the development environment We use the python poetry package to manage this package. Follow the official instructions to install poetry on your system then once you clone this repository just just need to do the following to install the dependencies from the development environment, as well as install spylib in editable mode : poetry install Then you can start monitoring the code for changes and run the test suite this way: poetry shell scripts/test_watch.sh Build and run documentation (lazydocs/mkdocs) Documentation for this package is handled by lazydocs and so it needs a few steps to generate it locally. Inside poetry shell : lazydocs --overview-file = \"index.md\" \\ --src-base-url = \"https://github.com/SatelCreative/satel-spylib/tree/main\" \\ --output-path = \"./docs/api-docs\" \\ --validate spylib mkdocs build mkdocs serve The default URL is at 127.0.0.1:8000 . Duplicating README.md and index.md The documentation homepage is stored in two locations: README.md : This is the homepage of the Github repository docs/index.md : This is the homepage in the documentation site generated by mkdocs We want only one homepage for simplicity sake so make sure to edit both files identically, or just edit one file and copy the new version to overwrite the other file when you're done editing. A Github action verifies that the two files are identical and will prevent a PR merge is they aren't. Publishing to pipy We use poetry to manage the dependencies and publish to pypi. Create branch release/x.y.z Change the version in the pyproject.toml and spylib/__init__.py files you can use poetry version XXXXX to change pyproject.toml Generate the CHANGELOG.md using auto-changelog : node_modules/auto-changelog/src/index.js --tag-pattern \"\\d+\\.\\d+(\\.\\d+)?\\$\" -v x.y.z Commit to git Open PR for other codeowners to review Once approved, squash and merge release/x.y.z Run poetry publish --build to create the package and publish to PyPI Tag the release in git and push it to Github Notes : It's better to tag after publishing in case there is an issue while publishing","title":"Development - Contributing"},{"location":"development-contributing/#development-contributing","text":"","title":"Development - Contributing"},{"location":"development-contributing/#contributing","text":"If you want to contribute a small change/feature, the best is to just create a PR with your changes. For bigger changes/features it's best to open an issue first and discuss it to agree on the code organization and overall implementation before spending too much time on the code, unless you want to keep it in your own forked repo.","title":"Contributing"},{"location":"development-contributing/#setting-up-the-development-environment","text":"We use the python poetry package to manage this package. Follow the official instructions to install poetry on your system then once you clone this repository just just need to do the following to install the dependencies from the development environment, as well as install spylib in editable mode : poetry install Then you can start monitoring the code for changes and run the test suite this way: poetry shell scripts/test_watch.sh","title":"Setting up the development environment"},{"location":"development-contributing/#build-and-run-documentation-lazydocsmkdocs","text":"Documentation for this package is handled by lazydocs and so it needs a few steps to generate it locally. Inside poetry shell : lazydocs --overview-file = \"index.md\" \\ --src-base-url = \"https://github.com/SatelCreative/satel-spylib/tree/main\" \\ --output-path = \"./docs/api-docs\" \\ --validate spylib mkdocs build mkdocs serve The default URL is at 127.0.0.1:8000 .","title":"Build and run documentation (lazydocs/mkdocs)"},{"location":"development-contributing/#duplicating-readmemd-and-indexmd","text":"The documentation homepage is stored in two locations: README.md : This is the homepage of the Github repository docs/index.md : This is the homepage in the documentation site generated by mkdocs We want only one homepage for simplicity sake so make sure to edit both files identically, or just edit one file and copy the new version to overwrite the other file when you're done editing. A Github action verifies that the two files are identical and will prevent a PR merge is they aren't.","title":"Duplicating README.md and index.md"},{"location":"development-contributing/#publishing-to-pipy","text":"We use poetry to manage the dependencies and publish to pypi. Create branch release/x.y.z Change the version in the pyproject.toml and spylib/__init__.py files you can use poetry version XXXXX to change pyproject.toml Generate the CHANGELOG.md using auto-changelog : node_modules/auto-changelog/src/index.js --tag-pattern \"\\d+\\.\\d+(\\.\\d+)?\\$\" -v x.y.z Commit to git Open PR for other codeowners to review Once approved, squash and merge release/x.y.z Run poetry publish --build to create the package and publish to PyPI Tag the release in git and push it to Github Notes : It's better to tag after publishing in case there is an issue while publishing","title":"Publishing to pipy"},{"location":"oauth/","text":"Install an app through OAuth Notice there have been considerable changes to the oauth in version 0.3. The core of this change has been the move from environment variables to parameters in the init script for the routers. The following describes a very basic implementation. Rather than reimplementing for each app the Shopify OAuth authentication one can simple get a FastAPI router that provides the install and callback endpoints ready to handle the whole OAuth process. You just need to call init_oauth_router such that: from spylib.oauth import OfflineToken , OnlineToken , init_oauth_router async def my_post_install ( storename : str , offline_token : OfflineToken ): \"\"\"Function handling the offline token obtained at the end of the installation\"\"\" # Store to database pass async def my_post_login ( storename : str , online_token : OnlineToken ): \"\"\"Function handling the online token obtained at the end of the user login\"\"\" # Store to database pass oauth_router = init_oauth_router ( app_scopes = [ 'write_orders' , 'write_products' ], user_scopes = [ 'read_orders' , 'write_products' ], public_domain = 'my.app.com' , private_key = 'KEY_FOR_OAUTH_JWT' , api_key = 'SHOPIFY_APP_API_KEY' , api_secret_key = 'SHOPIFY_APP_SECRET_KEY' , app_handle = 'SHOPIFY_APP_HANDLE' , post_install = my_post_install , post_login = my_post_login , install_init_path = '/install_path' , callback_path = '/callback_path' , path_prefix = '/api' , ) The app_scopes are for the offline token and the user_scopes for the online token. The public_domain is used to set the callback URL used in the OAuth process. This library uses a JWT encoded nonce to avoid the need for a database or some other mechanism to track the nonce . This JWT has an expiration time and is unique for each OAuth process making it a valid nonce mechanism. The private_key parameter defines the key used to encode and decode this JWT. The api and secret key can be found inside your shopify app main configuration page. The app handle can be found in the same spot but needs to be pulled from the url: Go to your shopify app's editing page (The url should be https://partners.shopify.com/<partner_id>/apps/<app_id>/edit ) Open the console and run window.RailsData.user.app.handle . The result is the handle. The post_install and post_login provide a way to inject functions handling the result of the installation and the login processes respectivaly. They are meant in particular to record the offline and online tokens in your app's database. They can be synchronous or asynchronous functions taking the storename and the token as arguments. The install_init_path is used to set the path for initiating the OAuth process. It has a default value /shopify/auth . The callback_path is used to set the callback path once user has accepted the permissions required by installing the app. It has a default value /callback . The path_prefix applies to both install_init_path and callback_path and it's empty by default. With the example above the URL to install the app will be https://my.app.com/api/install_path and the callback URL will be https://my.app.com/api/callback_path","title":"Install an app through OAuth"},{"location":"oauth/#install-an-app-through-oauth","text":"Notice there have been considerable changes to the oauth in version 0.3. The core of this change has been the move from environment variables to parameters in the init script for the routers. The following describes a very basic implementation. Rather than reimplementing for each app the Shopify OAuth authentication one can simple get a FastAPI router that provides the install and callback endpoints ready to handle the whole OAuth process. You just need to call init_oauth_router such that: from spylib.oauth import OfflineToken , OnlineToken , init_oauth_router async def my_post_install ( storename : str , offline_token : OfflineToken ): \"\"\"Function handling the offline token obtained at the end of the installation\"\"\" # Store to database pass async def my_post_login ( storename : str , online_token : OnlineToken ): \"\"\"Function handling the online token obtained at the end of the user login\"\"\" # Store to database pass oauth_router = init_oauth_router ( app_scopes = [ 'write_orders' , 'write_products' ], user_scopes = [ 'read_orders' , 'write_products' ], public_domain = 'my.app.com' , private_key = 'KEY_FOR_OAUTH_JWT' , api_key = 'SHOPIFY_APP_API_KEY' , api_secret_key = 'SHOPIFY_APP_SECRET_KEY' , app_handle = 'SHOPIFY_APP_HANDLE' , post_install = my_post_install , post_login = my_post_login , install_init_path = '/install_path' , callback_path = '/callback_path' , path_prefix = '/api' , ) The app_scopes are for the offline token and the user_scopes for the online token. The public_domain is used to set the callback URL used in the OAuth process. This library uses a JWT encoded nonce to avoid the need for a database or some other mechanism to track the nonce . This JWT has an expiration time and is unique for each OAuth process making it a valid nonce mechanism. The private_key parameter defines the key used to encode and decode this JWT. The api and secret key can be found inside your shopify app main configuration page. The app handle can be found in the same spot but needs to be pulled from the url: Go to your shopify app's editing page (The url should be https://partners.shopify.com/<partner_id>/apps/<app_id>/edit ) Open the console and run window.RailsData.user.app.handle . The result is the handle. The post_install and post_login provide a way to inject functions handling the result of the installation and the login processes respectivaly. They are meant in particular to record the offline and online tokens in your app's database. They can be synchronous or asynchronous functions taking the storename and the token as arguments. The install_init_path is used to set the path for initiating the OAuth process. It has a default value /shopify/auth . The callback_path is used to set the callback path once user has accepted the permissions required by installing the app. It has a default value /callback . The path_prefix applies to both install_init_path and callback_path and it's empty by default. With the example above the URL to install the app will be https://my.app.com/api/install_path and the callback URL will be https://my.app.com/api/callback_path","title":"Install an app through OAuth"},{"location":"session-token/","text":"Session Tokens The session token functionality can be used to verify the session for the user. The suggested syntax is to define a dependency: from spylib.utils import SessionToken def parse_session_token ( request : Request ): SessionToken . from_header ( request . headers . get ( 'Authorization' ), api_key , secret ) This can be used in FastAPI in the following way: @app . get ( \"/items/\" ) async def read_items ( session : SessionToken = Depends ( parse_session_token )): # Some api code","title":"Session Tokens"},{"location":"session-token/#session-tokens","text":"The session token functionality can be used to verify the session for the user. The suggested syntax is to define a dependency: from spylib.utils import SessionToken def parse_session_token ( request : Request ): SessionToken . from_header ( request . headers . get ( 'Authorization' ), api_key , secret ) This can be used in FastAPI in the following way: @app . get ( \"/items/\" ) async def read_items ( session : SessionToken = Depends ( parse_session_token )): # Some api code","title":"Session Tokens"},{"location":"webhooks/","text":"Webhooks The webhook functionality can be used to register webhooks and validate that the webhook notifications are from Shopify Breaking Changes in version 0.6.0 : The param is_base64 used in function validate from module spylib.utils.hmac is renamed to use_base64 to better convey the meaning of the parameter Register Webhooks You can easily register your endpoint to receive webhooks from Shopify using an admin API access token: from spylib import OfflineTokenABC class OfflineToken ( OfflineTokenABC ): \"\"\"Example offline token\"\"\" async def save ( self ): # Write to storage pass async def load ( cls , store_name : str ): # API access scopes from https://shopify.dev/api/usage/access-scopes return cls ( store_name = store_name , scope = [ 'write_orders' ], access_token = 'ACCESS_TOKEN' ) async def register_webhook_with_http_endpoint (): token = await OfflineToken . load ( store_name = 'my-store' ) # topics from https://shopify.dev/api/admin-graphql/<API-VERSION>/enums/webhooksubscriptiontopic res = await token . create_http_webhook ( topic = 'ORDERS_CREATE' , callback_url = 'https://sometest.com/example' ) print ( f 'Webhook registered with id { res . id } ' ) Validate Webhooks Shopify webhooks are signed with an HMAC in a header. You can use is_webhook_valid to verify this signature : is_valid = is_webhook_valid ( data = 'data' , hmac_header = 'hmac' , api_secret_key = 'API_SECRET_KEY' ) if is_valid : # do something","title":"Webhooks"},{"location":"webhooks/#webhooks","text":"The webhook functionality can be used to register webhooks and validate that the webhook notifications are from Shopify Breaking Changes in version 0.6.0 : The param is_base64 used in function validate from module spylib.utils.hmac is renamed to use_base64 to better convey the meaning of the parameter","title":"Webhooks"},{"location":"webhooks/#register-webhooks","text":"You can easily register your endpoint to receive webhooks from Shopify using an admin API access token: from spylib import OfflineTokenABC class OfflineToken ( OfflineTokenABC ): \"\"\"Example offline token\"\"\" async def save ( self ): # Write to storage pass async def load ( cls , store_name : str ): # API access scopes from https://shopify.dev/api/usage/access-scopes return cls ( store_name = store_name , scope = [ 'write_orders' ], access_token = 'ACCESS_TOKEN' ) async def register_webhook_with_http_endpoint (): token = await OfflineToken . load ( store_name = 'my-store' ) # topics from https://shopify.dev/api/admin-graphql/<API-VERSION>/enums/webhooksubscriptiontopic res = await token . create_http_webhook ( topic = 'ORDERS_CREATE' , callback_url = 'https://sometest.com/example' ) print ( f 'Webhook registered with id { res . id } ' )","title":"Register Webhooks"},{"location":"webhooks/#validate-webhooks","text":"Shopify webhooks are signed with an HMAC in a header. You can use is_webhook_valid to verify this signature : is_valid = is_webhook_valid ( data = 'data' , hmac_header = 'hmac' , api_secret_key = 'API_SECRET_KEY' ) if is_valid : # do something","title":"Validate Webhooks"},{"location":"api-docs/","text":"API Overview Modules constants : These are the text error codes thrown by the GraphQL API. Although some errors exceptions token : Token constants. utils utils.domain utils.hmac utils.httpclient utils.misc utils.rest utils.shortuuid Classes exceptions.FastAPIImportError : Exception to identify errors when spylip.oauth is accessed without fastapi installed exceptions.ShopifyCallInvalidError : Exception to identify errors that our due to bad data sent by us exceptions.ShopifyError : Exception to identify any Shopify error exceptions.ShopifyExceedingMaxCostError : Exception to identify errors that are due to queries exceeding the max query size exceptions.ShopifyGQLError : Exception to identify any Shopify admin graphql error exceptions.ShopifyGQLUserError : Exception to identify any Shopify admin graphql error caused by the user mistake exceptions.ShopifyThrottledError : Exception to identify errors that are due to rate limit control token.AssociatedUser token.OfflineTokenABC : Offline tokens are used for long term access, and do not have a set expiry. token.OfflineTokenResponse token.OnlineTokenABC : Online tokens are used to implement applications that are authenticated with token.OnlineTokenResponse token.PrivateTokenABC : Private token implementation, when we are pulling this from the config file. token.Token : Abstract class for token objects. This should never be extended, as you token.WebhookResponse token.WebhookTopic : An enumeration. httpclient.HTTPClient rest.Method : An enumeration. rest.Request Functions exceptions.not_our_fault : Simple function to identify invalid Shopify calls, i.e. our mistake. token.ISEOF token.ISNONTERMINAL token.ISTERMINAL token.is_webhook_valid domain.domain_to_storename domain.store_domain : Very flexible conversion of a shop's subdomain or complete or incomplete url into a hmac.calculate_from_components hmac.calculate_from_message hmac.validate misc.get_unique_id misc.now_epoch shortuuid.int_to_string : Convert a number to a string, using the given alphabet. shortuuid.random : Generate and return a cryptographically-secure short random string This file was automatically generated via lazydocs .","title":"Overview"},{"location":"api-docs/#api-overview","text":"","title":"API Overview"},{"location":"api-docs/#modules","text":"constants : These are the text error codes thrown by the GraphQL API. Although some errors exceptions token : Token constants. utils utils.domain utils.hmac utils.httpclient utils.misc utils.rest utils.shortuuid","title":"Modules"},{"location":"api-docs/#classes","text":"exceptions.FastAPIImportError : Exception to identify errors when spylip.oauth is accessed without fastapi installed exceptions.ShopifyCallInvalidError : Exception to identify errors that our due to bad data sent by us exceptions.ShopifyError : Exception to identify any Shopify error exceptions.ShopifyExceedingMaxCostError : Exception to identify errors that are due to queries exceeding the max query size exceptions.ShopifyGQLError : Exception to identify any Shopify admin graphql error exceptions.ShopifyGQLUserError : Exception to identify any Shopify admin graphql error caused by the user mistake exceptions.ShopifyThrottledError : Exception to identify errors that are due to rate limit control token.AssociatedUser token.OfflineTokenABC : Offline tokens are used for long term access, and do not have a set expiry. token.OfflineTokenResponse token.OnlineTokenABC : Online tokens are used to implement applications that are authenticated with token.OnlineTokenResponse token.PrivateTokenABC : Private token implementation, when we are pulling this from the config file. token.Token : Abstract class for token objects. This should never be extended, as you token.WebhookResponse token.WebhookTopic : An enumeration. httpclient.HTTPClient rest.Method : An enumeration. rest.Request","title":"Classes"},{"location":"api-docs/#functions","text":"exceptions.not_our_fault : Simple function to identify invalid Shopify calls, i.e. our mistake. token.ISEOF token.ISNONTERMINAL token.ISTERMINAL token.is_webhook_valid domain.domain_to_storename domain.store_domain : Very flexible conversion of a shop's subdomain or complete or incomplete url into a hmac.calculate_from_components hmac.calculate_from_message hmac.validate misc.get_unique_id misc.now_epoch shortuuid.int_to_string : Convert a number to a string, using the given alphabet. shortuuid.random : Generate and return a cryptographically-secure short random string This file was automatically generated via lazydocs .","title":"Functions"},{"location":"api-docs/constants/","text":"module constants These are the text error codes thrown by the GraphQL API. Although some errors throw a code e.g. \"errors\": [ { \"message\": \"Throttled\", \"extensions\": { \"code\": \"THROTTLED\" } } Not all provide the code parameter. Although you could just handle errors based on the message, this becomes very difficult as some of the messages are very long (see the max_cost_exceeded error output, which is ~350 characters) Global Variables THROTTLED_ERROR_CODE MAX_COST_EXCEEDED_ERROR_CODE OPERATION_NAME_REQUIRED_ERROR_MESSAGE WRONG_OPERATION_NAME_ERROR_MESSAGE This file was automatically generated via lazydocs .","title":"Constants"},{"location":"api-docs/constants/#module-constants","text":"These are the text error codes thrown by the GraphQL API. Although some errors throw a code e.g. \"errors\": [ { \"message\": \"Throttled\", \"extensions\": { \"code\": \"THROTTLED\" } } Not all provide the code parameter. Although you could just handle errors based on the message, this becomes very difficult as some of the messages are very long (see the max_cost_exceeded error output, which is ~350 characters)","title":"module constants"},{"location":"api-docs/constants/#global-variables","text":"THROTTLED_ERROR_CODE MAX_COST_EXCEEDED_ERROR_CODE OPERATION_NAME_REQUIRED_ERROR_MESSAGE WRONG_OPERATION_NAME_ERROR_MESSAGE This file was automatically generated via lazydocs .","title":"Global Variables"},{"location":"api-docs/exceptions/","text":"module exceptions function not_our_fault not_our_fault ( exception : Exception ) Simple function to identify invalid Shopify calls, i.e. our mistake. Probably the only way to make sure we retry for any other exception but those. class ShopifyError Exception to identify any Shopify error class ShopifyGQLError Exception to identify any Shopify admin graphql error class ShopifyGQLUserError Exception to identify any Shopify admin graphql error caused by the user mistake class ShopifyCallInvalidError Exception to identify errors that our due to bad data sent by us These should not be retried class ShopifyThrottledError Exception to identify errors that are due to rate limit control class ShopifyExceedingMaxCostError Exception to identify errors that are due to queries exceeding the max query size class FastAPIImportError Exception to identify errors when spylip.oauth is accessed without fastapi installed This file was automatically generated via lazydocs .","title":"Exceptions"},{"location":"api-docs/exceptions/#module-exceptions","text":"","title":"module exceptions"},{"location":"api-docs/exceptions/#function-not_our_fault","text":"not_our_fault ( exception : Exception ) Simple function to identify invalid Shopify calls, i.e. our mistake. Probably the only way to make sure we retry for any other exception but those.","title":"function not_our_fault"},{"location":"api-docs/exceptions/#class-shopifyerror","text":"Exception to identify any Shopify error","title":"class ShopifyError"},{"location":"api-docs/exceptions/#class-shopifygqlerror","text":"Exception to identify any Shopify admin graphql error","title":"class ShopifyGQLError"},{"location":"api-docs/exceptions/#class-shopifygqlusererror","text":"Exception to identify any Shopify admin graphql error caused by the user mistake","title":"class ShopifyGQLUserError"},{"location":"api-docs/exceptions/#class-shopifycallinvaliderror","text":"Exception to identify errors that our due to bad data sent by us These should not be retried","title":"class ShopifyCallInvalidError"},{"location":"api-docs/exceptions/#class-shopifythrottlederror","text":"Exception to identify errors that are due to rate limit control","title":"class ShopifyThrottledError"},{"location":"api-docs/exceptions/#class-shopifyexceedingmaxcosterror","text":"Exception to identify errors that are due to queries exceeding the max query size","title":"class ShopifyExceedingMaxCostError"},{"location":"api-docs/exceptions/#class-fastapiimporterror","text":"Exception to identify errors when spylip.oauth is accessed without fastapi installed This file was automatically generated via lazydocs .","title":"class FastAPIImportError"},{"location":"api-docs/token/","text":"module token Token constants. Global Variables ENDMARKER NAME NUMBER STRING NEWLINE INDENT DEDENT LPAR RPAR LSQB RSQB COLON COMMA SEMI PLUS MINUS STAR SLASH VBAR AMPER LESS GREATER EQUAL DOT PERCENT LBRACE RBRACE EQEQUAL NOTEQUAL LESSEQUAL GREATEREQUAL TILDE CIRCUMFLEX LEFTSHIFT RIGHTSHIFT DOUBLESTAR PLUSEQUAL MINEQUAL STAREQUAL SLASHEQUAL PERCENTEQUAL AMPEREQUAL VBAREQUAL CIRCUMFLEXEQUAL LEFTSHIFTEQUAL RIGHTSHIFTEQUAL DOUBLESTAREQUAL DOUBLESLASH DOUBLESLASHEQUAL AT ATEQUAL RARROW ELLIPSIS COLONEQUAL OP AWAIT ASYNC TYPE_IGNORE TYPE_COMMENT SOFT_KEYWORD ERRORTOKEN COMMENT NL ENCODING N_TOKENS NT_OFFSET tok_name EXACT_TOKEN_TYPES MAX_COST_EXCEEDED_ERROR_CODE OPERATION_NAME_REQUIRED_ERROR_MESSAGE THROTTLED_ERROR_CODE WRONG_OPERATION_NAME_ERROR_MESSAGE function ISTERMINAL ISTERMINAL ( x ) function ISNONTERMINAL ISNONTERMINAL ( x ) function ISEOF ISEOF ( x ) function is_webhook_valid is_webhook_valid ( data : str , hmac_header : str , api_secret_key : str ) \u2192 bool class AssociatedUser class OfflineTokenResponse class OnlineTokenResponse class WebhookTopic An enumeration. class WebhookResponse class Token Abstract class for token objects. This should never be extended, as you should either be using the OfflineTokenABC or the OnlineTokenABC. property api_url property oauth_url classmethod convert_scope convert_scope ( v ) method create_event_bridge_webhook create_event_bridge_webhook ( topic : Union [ WebhookTopic , str ], arn : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse method create_http_webhook create_http_webhook ( topic : Union [ WebhookTopic , str ], callback_url : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to create a webhook method create_pubsub_webhook create_pubsub_webhook ( topic : Union [ WebhookTopic , str ], pubsub_project : str , pubsub_topic : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse class OfflineTokenABC Offline tokens are used for long term access, and do not have a set expiry. property api_url property oauth_url classmethod convert_scope convert_scope ( v ) method create_event_bridge_webhook create_event_bridge_webhook ( topic : Union [ WebhookTopic , str ], arn : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse method create_http_webhook create_http_webhook ( topic : Union [ WebhookTopic , str ], callback_url : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to create a webhook method create_pubsub_webhook create_pubsub_webhook ( topic : Union [ WebhookTopic , str ], pubsub_project : str , pubsub_topic : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse classmethod load load ( store_name : str ) method save save () class OnlineTokenABC Online tokens are used to implement applications that are authenticated with a specific user's credentials. These extend on the original token, adding in a user, its scope and an expiry time. property api_url property oauth_url classmethod convert_scope convert_scope ( v ) method create_event_bridge_webhook create_event_bridge_webhook ( topic : Union [ WebhookTopic , str ], arn : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse method create_http_webhook create_http_webhook ( topic : Union [ WebhookTopic , str ], callback_url : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to create a webhook method create_pubsub_webhook create_pubsub_webhook ( topic : Union [ WebhookTopic , str ], pubsub_project : str , pubsub_topic : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse classmethod load load ( store_name : str , associated_user : str ) This method handles loading the token. By default this does nothing, therefore the developer should override this. method save save () This method handles saving the token. By default this does nothing, therefore the developer should override this. class PrivateTokenABC Private token implementation, when we are pulling this from the config file. Therefore we do not need the save function for the token class as there is no calls to the OAuth endpoints for shopify. property api_url property oauth_url classmethod convert_scope convert_scope ( v ) method create_event_bridge_webhook create_event_bridge_webhook ( topic : Union [ WebhookTopic , str ], arn : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse method create_http_webhook create_http_webhook ( topic : Union [ WebhookTopic , str ], callback_url : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to create a webhook method create_pubsub_webhook create_pubsub_webhook ( topic : Union [ WebhookTopic , str ], pubsub_project : str , pubsub_topic : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse classmethod load load ( store_name : str ) This method handles loading the token. By default this does nothing, therefore the developer should override this. This file was automatically generated via lazydocs .","title":"Token"},{"location":"api-docs/token/#module-token","text":"Token constants.","title":"module token"},{"location":"api-docs/token/#global-variables","text":"ENDMARKER NAME NUMBER STRING NEWLINE INDENT DEDENT LPAR RPAR LSQB RSQB COLON COMMA SEMI PLUS MINUS STAR SLASH VBAR AMPER LESS GREATER EQUAL DOT PERCENT LBRACE RBRACE EQEQUAL NOTEQUAL LESSEQUAL GREATEREQUAL TILDE CIRCUMFLEX LEFTSHIFT RIGHTSHIFT DOUBLESTAR PLUSEQUAL MINEQUAL STAREQUAL SLASHEQUAL PERCENTEQUAL AMPEREQUAL VBAREQUAL CIRCUMFLEXEQUAL LEFTSHIFTEQUAL RIGHTSHIFTEQUAL DOUBLESTAREQUAL DOUBLESLASH DOUBLESLASHEQUAL AT ATEQUAL RARROW ELLIPSIS COLONEQUAL OP AWAIT ASYNC TYPE_IGNORE TYPE_COMMENT SOFT_KEYWORD ERRORTOKEN COMMENT NL ENCODING N_TOKENS NT_OFFSET tok_name EXACT_TOKEN_TYPES MAX_COST_EXCEEDED_ERROR_CODE OPERATION_NAME_REQUIRED_ERROR_MESSAGE THROTTLED_ERROR_CODE WRONG_OPERATION_NAME_ERROR_MESSAGE","title":"Global Variables"},{"location":"api-docs/token/#function-isterminal","text":"ISTERMINAL ( x )","title":"function ISTERMINAL"},{"location":"api-docs/token/#function-isnonterminal","text":"ISNONTERMINAL ( x )","title":"function ISNONTERMINAL"},{"location":"api-docs/token/#function-iseof","text":"ISEOF ( x )","title":"function ISEOF"},{"location":"api-docs/token/#function-is_webhook_valid","text":"is_webhook_valid ( data : str , hmac_header : str , api_secret_key : str ) \u2192 bool","title":"function is_webhook_valid"},{"location":"api-docs/token/#class-associateduser","text":"","title":"class AssociatedUser"},{"location":"api-docs/token/#class-offlinetokenresponse","text":"","title":"class OfflineTokenResponse"},{"location":"api-docs/token/#class-onlinetokenresponse","text":"","title":"class OnlineTokenResponse"},{"location":"api-docs/token/#class-webhooktopic","text":"An enumeration.","title":"class WebhookTopic"},{"location":"api-docs/token/#class-webhookresponse","text":"","title":"class WebhookResponse"},{"location":"api-docs/token/#class-token","text":"Abstract class for token objects. This should never be extended, as you should either be using the OfflineTokenABC or the OnlineTokenABC.","title":"class Token"},{"location":"api-docs/token/#property-api_url","text":"","title":"property api_url"},{"location":"api-docs/token/#property-oauth_url","text":"","title":"property oauth_url"},{"location":"api-docs/token/#classmethod-convert_scope","text":"convert_scope ( v )","title":"classmethod convert_scope"},{"location":"api-docs/token/#method-create_event_bridge_webhook","text":"create_event_bridge_webhook ( topic : Union [ WebhookTopic , str ], arn : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse","title":"method create_event_bridge_webhook"},{"location":"api-docs/token/#method-create_http_webhook","text":"create_http_webhook ( topic : Union [ WebhookTopic , str ], callback_url : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to create a webhook","title":"method create_http_webhook"},{"location":"api-docs/token/#method-create_pubsub_webhook","text":"create_pubsub_webhook ( topic : Union [ WebhookTopic , str ], pubsub_project : str , pubsub_topic : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse","title":"method create_pubsub_webhook"},{"location":"api-docs/token/#class-offlinetokenabc","text":"Offline tokens are used for long term access, and do not have a set expiry.","title":"class OfflineTokenABC"},{"location":"api-docs/token/#property-api_url_1","text":"","title":"property api_url"},{"location":"api-docs/token/#property-oauth_url_1","text":"","title":"property oauth_url"},{"location":"api-docs/token/#classmethod-convert_scope_1","text":"convert_scope ( v )","title":"classmethod convert_scope"},{"location":"api-docs/token/#method-create_event_bridge_webhook_1","text":"create_event_bridge_webhook ( topic : Union [ WebhookTopic , str ], arn : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse","title":"method create_event_bridge_webhook"},{"location":"api-docs/token/#method-create_http_webhook_1","text":"create_http_webhook ( topic : Union [ WebhookTopic , str ], callback_url : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to create a webhook","title":"method create_http_webhook"},{"location":"api-docs/token/#method-create_pubsub_webhook_1","text":"create_pubsub_webhook ( topic : Union [ WebhookTopic , str ], pubsub_project : str , pubsub_topic : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse","title":"method create_pubsub_webhook"},{"location":"api-docs/token/#classmethod-load","text":"load ( store_name : str )","title":"classmethod load"},{"location":"api-docs/token/#method-save","text":"save ()","title":"method save"},{"location":"api-docs/token/#class-onlinetokenabc","text":"Online tokens are used to implement applications that are authenticated with a specific user's credentials. These extend on the original token, adding in a user, its scope and an expiry time.","title":"class OnlineTokenABC"},{"location":"api-docs/token/#property-api_url_2","text":"","title":"property api_url"},{"location":"api-docs/token/#property-oauth_url_2","text":"","title":"property oauth_url"},{"location":"api-docs/token/#classmethod-convert_scope_2","text":"convert_scope ( v )","title":"classmethod convert_scope"},{"location":"api-docs/token/#method-create_event_bridge_webhook_2","text":"create_event_bridge_webhook ( topic : Union [ WebhookTopic , str ], arn : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse","title":"method create_event_bridge_webhook"},{"location":"api-docs/token/#method-create_http_webhook_2","text":"create_http_webhook ( topic : Union [ WebhookTopic , str ], callback_url : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to create a webhook","title":"method create_http_webhook"},{"location":"api-docs/token/#method-create_pubsub_webhook_2","text":"create_pubsub_webhook ( topic : Union [ WebhookTopic , str ], pubsub_project : str , pubsub_topic : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse","title":"method create_pubsub_webhook"},{"location":"api-docs/token/#classmethod-load_1","text":"load ( store_name : str , associated_user : str ) This method handles loading the token. By default this does nothing, therefore the developer should override this.","title":"classmethod load"},{"location":"api-docs/token/#method-save_1","text":"save () This method handles saving the token. By default this does nothing, therefore the developer should override this.","title":"method save"},{"location":"api-docs/token/#class-privatetokenabc","text":"Private token implementation, when we are pulling this from the config file. Therefore we do not need the save function for the token class as there is no calls to the OAuth endpoints for shopify.","title":"class PrivateTokenABC"},{"location":"api-docs/token/#property-api_url_3","text":"","title":"property api_url"},{"location":"api-docs/token/#property-oauth_url_3","text":"","title":"property oauth_url"},{"location":"api-docs/token/#classmethod-convert_scope_3","text":"convert_scope ( v )","title":"classmethod convert_scope"},{"location":"api-docs/token/#method-create_event_bridge_webhook_3","text":"create_event_bridge_webhook ( topic : Union [ WebhookTopic , str ], arn : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse","title":"method create_event_bridge_webhook"},{"location":"api-docs/token/#method-create_http_webhook_3","text":"create_http_webhook ( topic : Union [ WebhookTopic , str ], callback_url : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to create a webhook","title":"method create_http_webhook"},{"location":"api-docs/token/#method-create_pubsub_webhook_3","text":"create_pubsub_webhook ( topic : Union [ WebhookTopic , str ], pubsub_project : str , pubsub_topic : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse","title":"method create_pubsub_webhook"},{"location":"api-docs/token/#classmethod-load_2","text":"load ( store_name : str ) This method handles loading the token. By default this does nothing, therefore the developer should override this. This file was automatically generated via lazydocs .","title":"classmethod load"},{"location":"api-docs/utils.domain/","text":"module utils.domain function domain_to_storename domain_to_storename ( domain : str ) \u2192 str function store_domain store_domain ( shop : str ) \u2192 str Very flexible conversion of a shop's subdomain or complete or incomplete url into a complete url This file was automatically generated via lazydocs .","title":"Utils.domain"},{"location":"api-docs/utils.domain/#module-utilsdomain","text":"","title":"module utils.domain"},{"location":"api-docs/utils.domain/#function-domain_to_storename","text":"domain_to_storename ( domain : str ) \u2192 str","title":"function domain_to_storename"},{"location":"api-docs/utils.domain/#function-store_domain","text":"store_domain ( shop : str ) \u2192 str Very flexible conversion of a shop's subdomain or complete or incomplete url into a complete url This file was automatically generated via lazydocs .","title":"function store_domain"},{"location":"api-docs/utils.hmac/","text":"module utils.hmac function calculate_from_message calculate_from_message ( secret : str , message : str , use_base64 : bool = False ) \u2192 str function calculate_from_components calculate_from_components ( datetime , path , query_string , body , secret , use_base64 : bool = False ) function validate validate ( secret : str , sent_hmac : str , message : str , use_base64 : bool = False ) This file was automatically generated via lazydocs .","title":"Utils.hmac"},{"location":"api-docs/utils.hmac/#module-utilshmac","text":"","title":"module utils.hmac"},{"location":"api-docs/utils.hmac/#function-calculate_from_message","text":"calculate_from_message ( secret : str , message : str , use_base64 : bool = False ) \u2192 str","title":"function calculate_from_message"},{"location":"api-docs/utils.hmac/#function-calculate_from_components","text":"calculate_from_components ( datetime , path , query_string , body , secret , use_base64 : bool = False )","title":"function calculate_from_components"},{"location":"api-docs/utils.hmac/#function-validate","text":"validate ( secret : str , sent_hmac : str , message : str , use_base64 : bool = False ) This file was automatically generated via lazydocs .","title":"function validate"},{"location":"api-docs/utils.httpclient/","text":"module utils.httpclient class HTTPClient property auth Authentication class used when none is passed at the request-level. See also Authentication . property base_url Base URL to use when sending requests with relative URLs. property cookies Cookie values to include when sending requests. property event_hooks property headers HTTP headers to include when sending requests. property is_closed Check if the client being closed property params Query parameters to include in the URL when sending requests. property timeout property trust_env classmethod close close () This file was automatically generated via lazydocs .","title":"Utils.httpclient"},{"location":"api-docs/utils.httpclient/#module-utilshttpclient","text":"","title":"module utils.httpclient"},{"location":"api-docs/utils.httpclient/#class-httpclient","text":"","title":"class HTTPClient"},{"location":"api-docs/utils.httpclient/#property-auth","text":"Authentication class used when none is passed at the request-level. See also Authentication .","title":"property auth"},{"location":"api-docs/utils.httpclient/#property-base_url","text":"Base URL to use when sending requests with relative URLs.","title":"property base_url"},{"location":"api-docs/utils.httpclient/#property-cookies","text":"Cookie values to include when sending requests.","title":"property cookies"},{"location":"api-docs/utils.httpclient/#property-event_hooks","text":"","title":"property event_hooks"},{"location":"api-docs/utils.httpclient/#property-headers","text":"HTTP headers to include when sending requests.","title":"property headers"},{"location":"api-docs/utils.httpclient/#property-is_closed","text":"Check if the client being closed","title":"property is_closed"},{"location":"api-docs/utils.httpclient/#property-params","text":"Query parameters to include in the URL when sending requests.","title":"property params"},{"location":"api-docs/utils.httpclient/#property-timeout","text":"","title":"property timeout"},{"location":"api-docs/utils.httpclient/#property-trust_env","text":"","title":"property trust_env"},{"location":"api-docs/utils.httpclient/#classmethod-close","text":"close () This file was automatically generated via lazydocs .","title":"classmethod close"},{"location":"api-docs/utils/","text":"module utils Global Variables domain hmac httpclient shortuuid : # Code copied over from shortuuid package: https://github.com/skorokithakis/shortuuid/blob/v1.0.8/shortuuid/main.py misc jwtoken rest session_token This file was automatically generated via lazydocs .","title":"Utils"},{"location":"api-docs/utils/#module-utils","text":"","title":"module utils"},{"location":"api-docs/utils/#global-variables","text":"domain hmac httpclient shortuuid : # Code copied over from shortuuid package:","title":"Global Variables"},{"location":"api-docs/utils/#httpsgithubcomskorokithakisshortuuidblobv108shortuuidmainpy","text":"misc jwtoken rest session_token This file was automatically generated via lazydocs .","title":"https://github.com/skorokithakis/shortuuid/blob/v1.0.8/shortuuid/main.py"},{"location":"api-docs/utils.misc/","text":"module utils.misc function now_epoch now_epoch () \u2192 int function get_unique_id get_unique_id () \u2192 str This file was automatically generated via lazydocs .","title":"Utils.misc"},{"location":"api-docs/utils.misc/#module-utilsmisc","text":"","title":"module utils.misc"},{"location":"api-docs/utils.misc/#function-now_epoch","text":"now_epoch () \u2192 int","title":"function now_epoch"},{"location":"api-docs/utils.misc/#function-get_unique_id","text":"get_unique_id () \u2192 str This file was automatically generated via lazydocs .","title":"function get_unique_id"},{"location":"api-docs/utils.rest/","text":"module utils.rest Global Variables GET POST PUT DELETE class Method An enumeration. class Request This file was automatically generated via lazydocs .","title":"Utils.rest"},{"location":"api-docs/utils.rest/#module-utilsrest","text":"","title":"module utils.rest"},{"location":"api-docs/utils.rest/#global-variables","text":"GET POST PUT DELETE","title":"Global Variables"},{"location":"api-docs/utils.rest/#class-method","text":"An enumeration.","title":"class Method"},{"location":"api-docs/utils.rest/#class-request","text":"This file was automatically generated via lazydocs .","title":"class Request"},{"location":"api-docs/utils.shortuuid/","text":"module utils.shortuuid Global Variables ALPHABET function random random ( length ) Generate and return a cryptographically-secure short random string of the specified length. function int_to_string int_to_string ( number , alphabet , padding = None ) Convert a number to a string, using the given alphabet. The output has the most significant digit first. This file was automatically generated via lazydocs .","title":"Utils.shortuuid"},{"location":"api-docs/utils.shortuuid/#module-utilsshortuuid","text":"","title":"module utils.shortuuid"},{"location":"api-docs/utils.shortuuid/#global-variables","text":"ALPHABET","title":"Global Variables"},{"location":"api-docs/utils.shortuuid/#function-random","text":"random ( length ) Generate and return a cryptographically-secure short random string of the specified length.","title":"function random"},{"location":"api-docs/utils.shortuuid/#function-int_to_string","text":"int_to_string ( number , alphabet , padding = None ) Convert a number to a string, using the given alphabet. The output has the most significant digit first. This file was automatically generated via lazydocs .","title":"function int_to_string"}]}