{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shopify Python Library - SPyLib The Shopify python library, or SPyLib, simplifies the use of the Shopify services such as the REST and GraphQL APIs as well as the OAuth authentication. All of this is done asynchronously using asyncio . Installation pip install spylib What can SPyLib do? Official documentation Shopify components managed by SPyLib: Admin API Install an app through OAuth Session tokens Webhooks Multipass","title":"Home"},{"location":"#shopify-python-library-spylib","text":"The Shopify python library, or SPyLib, simplifies the use of the Shopify services such as the REST and GraphQL APIs as well as the OAuth authentication. All of this is done asynchronously using asyncio .","title":"Shopify Python Library - SPyLib"},{"location":"#installation","text":"pip install spylib","title":"Installation"},{"location":"#what-can-spylib-do","text":"Official documentation Shopify components managed by SPyLib: Admin API Install an app through OAuth Session tokens Webhooks Multipass","title":"What can SPyLib do?"},{"location":"admin-api/","text":"Admin API Token The token class contains the majority of the logic for communicating with shopify. To use the token class, you must define a child class for the tokens you are using and implement a subset of the save and load abstract methods. Your option for child classes are OnlineTokenABC , OfflineTokenABC or PrivateTokenABC : Implement Token Classes class OfflineToken ( OfflineTokenABC ): async def save ( self ): # Some code to save the token to a database @classmethod async def load ( cls , store_name : str ): # Some code to load the token from the database class OnlineToken ( OnlineTokenABC ): async def save ( self ): # Some code to save the token to a database @classmethod async def load ( cls , store_name : str , user_id : str ): # Some code to load the token from the database class PrivateToken ( PrivateTokenABC ): @classmethod async def load ( cls , store_name : str , user_id : str ): # Some code to load the token from the database # No need for save, as it is static. Change Shopify API version As shown in the Implement Token Classes , token can be used as following: from spylib import OfflineTokenABC class OfflineToken ( OfflineTokenABC ): async def save ( self ): pass @classmethod async def load ( cls , store_name : str ): pass If the Shopify API version used in Spylib is not the desired version, it can be changed with the following: class OfflineToken ( OfflineTokenABC ): async def save ( self ): pass @classmethod async def load ( cls , store_name : str ): pass # Add the version to be used here OfflineToken . api_version : '2022-01' Create Token Once you have defined these methods, we can create an instance of a token using one of the following: token = OfflineToken ( store_name , access_token , scope ) token = OnlineToken ( store_name , access_token , scope , expires_in , associated_user_scope , associated_user_id ) token = PrivateToken ( store_name , access_token , scope ) Querying Shopify REST We can query the store using the REST endpoint: await token . execute_rest ( request : Request , endpoint : str , json : Optional [ Dict [ str , Any ]], debug : Optional [ str ], ) For example, if you want to query a product from shopify you can run: product_json = await token . execute_rest ( request = GET , endpoint = f '/products/ { product_id } .json' ) If you want to update a product in a shop you can run: product_json = await token . execute_rest ( request = PUT , endpoint = f '/products/ { product_id } .json' , json = { \"product\" : { \"id\" : product_id , \"title\" : \"New Title\" } } ) The REST method takes a request parameter which is one of the Request constants defined in the rest file. The options are GET , POST , PUT , or DELETE . Endpoint is the API endpoint string that we are querying, this should be similar to the following format: f '/ { resource } .json?fields= { resource . param } & { [ params ] } ' The debug parameter is the message that is returned when there is an error. It is optional as it defaults to \"\" . GraphQL We can also query Shopify using the GraphQL endpoint: token . execute_gql ( query : str , variables : Dict [ str , Any ], operation_name : Optional [ str ] ) For example, if you want to query a product from shopify you can run: query = \"\"\" { product(id: \"gid://shopify/Product/1974208299030\") { id, title } }\"\"\" product_json = await token . execute_gql ( query = query ) If you want to update a product in a shop you can run: query = \"\"\" mutation productUpdateMutation($id: ID, $title: String) { productUpdate(input: { id: $id, title: $title }) { product { id } } }\"\"\" variables = { 'id' : 'gid://shopify/Product/108828309' , 'title' : \"Sweet new product - GraphQL Edition\" } product_json = await token . execute_gql ( query = query , variables = variables ) The query is a GraphQL query that will be passed to shopify for execution. You can use the GQL explorer for your shop to create a query. For example, the shopify demo GQL explorer . The variables are a dictionary of variables that will be substituted into the query. The operation_name is a name for the query you are about to run.","title":"Admin API"},{"location":"admin-api/#admin-api","text":"","title":"Admin API"},{"location":"admin-api/#token","text":"The token class contains the majority of the logic for communicating with shopify. To use the token class, you must define a child class for the tokens you are using and implement a subset of the save and load abstract methods. Your option for child classes are OnlineTokenABC , OfflineTokenABC or PrivateTokenABC :","title":"Token"},{"location":"admin-api/#implement-token-classes","text":"class OfflineToken ( OfflineTokenABC ): async def save ( self ): # Some code to save the token to a database @classmethod async def load ( cls , store_name : str ): # Some code to load the token from the database class OnlineToken ( OnlineTokenABC ): async def save ( self ): # Some code to save the token to a database @classmethod async def load ( cls , store_name : str , user_id : str ): # Some code to load the token from the database class PrivateToken ( PrivateTokenABC ): @classmethod async def load ( cls , store_name : str , user_id : str ): # Some code to load the token from the database # No need for save, as it is static.","title":"Implement Token Classes"},{"location":"admin-api/#change-shopify-api-version","text":"As shown in the Implement Token Classes , token can be used as following: from spylib import OfflineTokenABC class OfflineToken ( OfflineTokenABC ): async def save ( self ): pass @classmethod async def load ( cls , store_name : str ): pass If the Shopify API version used in Spylib is not the desired version, it can be changed with the following: class OfflineToken ( OfflineTokenABC ): async def save ( self ): pass @classmethod async def load ( cls , store_name : str ): pass # Add the version to be used here OfflineToken . api_version : '2022-01'","title":"Change Shopify API version"},{"location":"admin-api/#create-token","text":"Once you have defined these methods, we can create an instance of a token using one of the following: token = OfflineToken ( store_name , access_token , scope ) token = OnlineToken ( store_name , access_token , scope , expires_in , associated_user_scope , associated_user_id ) token = PrivateToken ( store_name , access_token , scope )","title":"Create Token"},{"location":"admin-api/#querying-shopify","text":"","title":"Querying Shopify"},{"location":"admin-api/#rest","text":"We can query the store using the REST endpoint: await token . execute_rest ( request : Request , endpoint : str , json : Optional [ Dict [ str , Any ]], debug : Optional [ str ], ) For example, if you want to query a product from shopify you can run: product_json = await token . execute_rest ( request = GET , endpoint = f '/products/ { product_id } .json' ) If you want to update a product in a shop you can run: product_json = await token . execute_rest ( request = PUT , endpoint = f '/products/ { product_id } .json' , json = { \"product\" : { \"id\" : product_id , \"title\" : \"New Title\" } } ) The REST method takes a request parameter which is one of the Request constants defined in the rest file. The options are GET , POST , PUT , or DELETE . Endpoint is the API endpoint string that we are querying, this should be similar to the following format: f '/ { resource } .json?fields= { resource . param } & { [ params ] } ' The debug parameter is the message that is returned when there is an error. It is optional as it defaults to \"\" .","title":"REST"},{"location":"admin-api/#graphql","text":"We can also query Shopify using the GraphQL endpoint: token . execute_gql ( query : str , variables : Dict [ str , Any ], operation_name : Optional [ str ] ) For example, if you want to query a product from shopify you can run: query = \"\"\" { product(id: \"gid://shopify/Product/1974208299030\") { id, title } }\"\"\" product_json = await token . execute_gql ( query = query ) If you want to update a product in a shop you can run: query = \"\"\" mutation productUpdateMutation($id: ID, $title: String) { productUpdate(input: { id: $id, title: $title }) { product { id } } }\"\"\" variables = { 'id' : 'gid://shopify/Product/108828309' , 'title' : \"Sweet new product - GraphQL Edition\" } product_json = await token . execute_gql ( query = query , variables = variables ) The query is a GraphQL query that will be passed to shopify for execution. You can use the GQL explorer for your shop to create a query. For example, the shopify demo GQL explorer . The variables are a dictionary of variables that will be substituted into the query. The operation_name is a name for the query you are about to run.","title":"GraphQL"},{"location":"development-contributing/","text":"Development - Contributing Contributing If you want to contribute a small change/feature, the best is to just create a PR with your changes. For bigger changes/features it's best to open an issue first and discuss it to agree on the code organization and overall implementation before spending too much time on the code, unless you want to keep it in your own forked repo. Setting up the development environment We use the python poetry package to manage this package. Follow the official instructions to install poetry on your system then once you clone this repository just just need to do the following to install the dependencies from the development environment, as well as install spylib in editable mode : poetry install Then you can start monitoring the code for changes and run the test suite this way: poetry shell scripts/test_watch.sh Build and run documentation (lazydocs/mkdocs) Documentation for this package is handled by lazydocs and so it needs a few steps to generate it locally. Inside poetry shell : lazydocs --overview-file = \"index.md\" \\ --src-base-url = \"https://github.com/SatelCreative/spylib/tree/main\" \\ --output-path = \"./docs/api-docs\" \\ spylib mkdocs build mkdocs serve The default URL is at 127.0.0.1:8000 . Duplicating README.md and index.md The documentation homepage is stored in two locations: README.md : This is the homepage of the Github repository docs/index.md : This is the homepage in the documentation site generated by mkdocs We want only one homepage for simplicity sake so make sure to edit both files identically, or just edit one file and copy the new version to overwrite the other file when you're done editing. A Github action verifies that the two files are identical and will prevent a PR merge is they aren't. Publishing to PyPI We use poetry to manage the dependencies and publish to PyPI. Create branch release/x.y.z Change the version in the pyproject.toml and spylib/__init__.py files you can use poetry version XXXXX to change pyproject.toml Generate the CHANGELOG.md using Github's automatically generated release notes , but don't create the release , just make the changelog through the UI. Commit to git Open PR for other codeowners to review Once approved, squash and merge release/x.y.z Run poetry publish --build to create the package and publish to PyPI Create the matching release in Github with Github's automatically generated release notes Notes : It's better to tag after publishing in case there is an issue while publishing","title":"Development - Contributing"},{"location":"development-contributing/#development-contributing","text":"","title":"Development - Contributing"},{"location":"development-contributing/#contributing","text":"If you want to contribute a small change/feature, the best is to just create a PR with your changes. For bigger changes/features it's best to open an issue first and discuss it to agree on the code organization and overall implementation before spending too much time on the code, unless you want to keep it in your own forked repo.","title":"Contributing"},{"location":"development-contributing/#setting-up-the-development-environment","text":"We use the python poetry package to manage this package. Follow the official instructions to install poetry on your system then once you clone this repository just just need to do the following to install the dependencies from the development environment, as well as install spylib in editable mode : poetry install Then you can start monitoring the code for changes and run the test suite this way: poetry shell scripts/test_watch.sh","title":"Setting up the development environment"},{"location":"development-contributing/#build-and-run-documentation-lazydocsmkdocs","text":"Documentation for this package is handled by lazydocs and so it needs a few steps to generate it locally. Inside poetry shell : lazydocs --overview-file = \"index.md\" \\ --src-base-url = \"https://github.com/SatelCreative/spylib/tree/main\" \\ --output-path = \"./docs/api-docs\" \\ spylib mkdocs build mkdocs serve The default URL is at 127.0.0.1:8000 .","title":"Build and run documentation (lazydocs/mkdocs)"},{"location":"development-contributing/#duplicating-readmemd-and-indexmd","text":"The documentation homepage is stored in two locations: README.md : This is the homepage of the Github repository docs/index.md : This is the homepage in the documentation site generated by mkdocs We want only one homepage for simplicity sake so make sure to edit both files identically, or just edit one file and copy the new version to overwrite the other file when you're done editing. A Github action verifies that the two files are identical and will prevent a PR merge is they aren't.","title":"Duplicating README.md and index.md"},{"location":"development-contributing/#publishing-to-pypi","text":"We use poetry to manage the dependencies and publish to PyPI. Create branch release/x.y.z Change the version in the pyproject.toml and spylib/__init__.py files you can use poetry version XXXXX to change pyproject.toml Generate the CHANGELOG.md using Github's automatically generated release notes , but don't create the release , just make the changelog through the UI. Commit to git Open PR for other codeowners to review Once approved, squash and merge release/x.y.z Run poetry publish --build to create the package and publish to PyPI Create the matching release in Github with Github's automatically generated release notes Notes : It's better to tag after publishing in case there is an issue while publishing","title":"Publishing to PyPI"},{"location":"hmac/","text":"HMAC The hmac functionality can be used to validate the following Shopify requests: - OAuth - Webhook - App Proxy from spylib.hmac import validate # use_base64 is set to False by default, set it to True for verifying webhook hmac def validate_webhook_hmac ( data : str , hmac_header : str , api_secret_key : str ): validate ( secret = api_secret_key , sent_hmac = hmac_header , message = data , use_base64 = True )","title":"HMAC"},{"location":"hmac/#hmac","text":"The hmac functionality can be used to validate the following Shopify requests: - OAuth - Webhook - App Proxy from spylib.hmac import validate # use_base64 is set to False by default, set it to True for verifying webhook hmac def validate_webhook_hmac ( data : str , hmac_header : str , api_secret_key : str ): validate ( secret = api_secret_key , sent_hmac = hmac_header , message = data , use_base64 = True )","title":"HMAC"},{"location":"multipass/","text":"Multipass Shopify Multipass - Shopify Documentation This helper class generates token or URL that's needed for Shopify Multipass login. from spylib import multipass # Customer email is required to generate token or URL customer_data = { 'email' : 'customer@email.com' } # Generate URL url = multipass . generate_url ( secret = 'MULTIPASS_SECRET' , customer_data = customer_data , store_url = 'https://example.myshopify.com' ) # https://example.myshopify.com/account/login/multipass/{MultipassToken} # If for some reason you need the token, you can also generate the token used in the URL separately: token = multipass . generate_token ( secret = 'MULTIPASS_SECRET' , customer_data = customer_data )","title":"Multipass"},{"location":"multipass/#multipass","text":"Shopify Multipass - Shopify Documentation This helper class generates token or URL that's needed for Shopify Multipass login. from spylib import multipass # Customer email is required to generate token or URL customer_data = { 'email' : 'customer@email.com' } # Generate URL url = multipass . generate_url ( secret = 'MULTIPASS_SECRET' , customer_data = customer_data , store_url = 'https://example.myshopify.com' ) # https://example.myshopify.com/account/login/multipass/{MultipassToken} # If for some reason you need the token, you can also generate the token used in the URL separately: token = multipass . generate_token ( secret = 'MULTIPASS_SECRET' , customer_data = customer_data )","title":"Multipass"},{"location":"oauth/","text":"Install an app through OAuth Notice there have been considerable changes to the oauth in version 0.3. The core of this change has been the move from environment variables to parameters in the init script for the routers. The following describes a very basic implementation. Rather than reimplementing for each app the Shopify OAuth authentication one can simple get a FastAPI router that provides the install and callback endpoints ready to handle the whole OAuth process. You just need to call init_oauth_router such that: from spylib.oauth import OfflineToken , OnlineToken , init_oauth_router async def my_post_install ( storename : str , offline_token : OfflineToken ): \"\"\"Function handling the offline token obtained at the end of the installation\"\"\" # Store to database pass async def my_post_login ( storename : str , online_token : OnlineToken ): \"\"\"Function handling the online token obtained at the end of the user login\"\"\" # Store to database pass oauth_router = init_oauth_router ( app_scopes = [ 'write_orders' , 'write_products' ], user_scopes = [ 'read_orders' , 'write_products' ], public_domain = 'my.app.com' , private_key = 'KEY_FOR_OAUTH_JWT' , api_key = 'SHOPIFY_APP_API_KEY' , api_secret_key = 'SHOPIFY_APP_SECRET_KEY' , app_handle = 'SHOPIFY_APP_HANDLE' , post_install = my_post_install , post_login = my_post_login , install_init_path = '/install_path' , callback_path = '/callback_path' , path_prefix = '/api' , ) The app_scopes are for the offline token and the user_scopes for the online token. The public_domain is used to set the callback URL used in the OAuth process. This library uses a JWT encoded nonce to avoid the need for a database or some other mechanism to track the nonce . This JWT has an expiration time and is unique for each OAuth process making it a valid nonce mechanism. The private_key parameter defines the key used to encode and decode this JWT. The api and secret key can be found inside your shopify app main configuration page. The app handle can be found in the same spot but needs to be pulled from the url: Go to your shopify app's editing page (The url should be https://partners.shopify.com/<partner_id>/apps/<app_id>/edit ) Open the console and run window.RailsData.user.app.handle . The result is the handle. The post_install and post_login provide a way to inject functions handling the result of the installation and the login processes respectivaly. They are meant in particular to record the offline and online tokens in your app's database. They can be synchronous or asynchronous functions taking the storename and the token as arguments. The install_init_path is used to set the path for initiating the OAuth process. It has a default value /shopify/auth . The callback_path is used to set the callback path once user has accepted the permissions required by installing the app. It has a default value /callback . The path_prefix applies to both install_init_path and callback_path and it's empty by default. With the example above the URL to install the app will be https://my.app.com/api/install_path and the callback URL will be https://my.app.com/api/callback_path","title":"Install an app through OAuth"},{"location":"oauth/#install-an-app-through-oauth","text":"Notice there have been considerable changes to the oauth in version 0.3. The core of this change has been the move from environment variables to parameters in the init script for the routers. The following describes a very basic implementation. Rather than reimplementing for each app the Shopify OAuth authentication one can simple get a FastAPI router that provides the install and callback endpoints ready to handle the whole OAuth process. You just need to call init_oauth_router such that: from spylib.oauth import OfflineToken , OnlineToken , init_oauth_router async def my_post_install ( storename : str , offline_token : OfflineToken ): \"\"\"Function handling the offline token obtained at the end of the installation\"\"\" # Store to database pass async def my_post_login ( storename : str , online_token : OnlineToken ): \"\"\"Function handling the online token obtained at the end of the user login\"\"\" # Store to database pass oauth_router = init_oauth_router ( app_scopes = [ 'write_orders' , 'write_products' ], user_scopes = [ 'read_orders' , 'write_products' ], public_domain = 'my.app.com' , private_key = 'KEY_FOR_OAUTH_JWT' , api_key = 'SHOPIFY_APP_API_KEY' , api_secret_key = 'SHOPIFY_APP_SECRET_KEY' , app_handle = 'SHOPIFY_APP_HANDLE' , post_install = my_post_install , post_login = my_post_login , install_init_path = '/install_path' , callback_path = '/callback_path' , path_prefix = '/api' , ) The app_scopes are for the offline token and the user_scopes for the online token. The public_domain is used to set the callback URL used in the OAuth process. This library uses a JWT encoded nonce to avoid the need for a database or some other mechanism to track the nonce . This JWT has an expiration time and is unique for each OAuth process making it a valid nonce mechanism. The private_key parameter defines the key used to encode and decode this JWT. The api and secret key can be found inside your shopify app main configuration page. The app handle can be found in the same spot but needs to be pulled from the url: Go to your shopify app's editing page (The url should be https://partners.shopify.com/<partner_id>/apps/<app_id>/edit ) Open the console and run window.RailsData.user.app.handle . The result is the handle. The post_install and post_login provide a way to inject functions handling the result of the installation and the login processes respectivaly. They are meant in particular to record the offline and online tokens in your app's database. They can be synchronous or asynchronous functions taking the storename and the token as arguments. The install_init_path is used to set the path for initiating the OAuth process. It has a default value /shopify/auth . The callback_path is used to set the callback path once user has accepted the permissions required by installing the app. It has a default value /callback . The path_prefix applies to both install_init_path and callback_path and it's empty by default. With the example above the URL to install the app will be https://my.app.com/api/install_path and the callback URL will be https://my.app.com/api/callback_path","title":"Install an app through OAuth"},{"location":"session-token/","text":"Session Tokens The session token functionality can be used to verify the session for the user. The suggested syntax is to define a dependency: from spylib.utils import SessionToken def parse_session_token ( request : Request ): SessionToken . from_header ( request . headers . get ( 'Authorization' ), api_key , secret ) This can be used in FastAPI in the following way: @app . get ( \"/items/\" ) async def read_items ( session : SessionToken = Depends ( parse_session_token )): # Some api code","title":"Session Tokens"},{"location":"session-token/#session-tokens","text":"The session token functionality can be used to verify the session for the user. The suggested syntax is to define a dependency: from spylib.utils import SessionToken def parse_session_token ( request : Request ): SessionToken . from_header ( request . headers . get ( 'Authorization' ), api_key , secret ) This can be used in FastAPI in the following way: @app . get ( \"/items/\" ) async def read_items ( session : SessionToken = Depends ( parse_session_token )): # Some api code","title":"Session Tokens"},{"location":"webhooks/","text":"Webhooks The webhook functionality can be used to register webhooks and validate that the webhook notifications are from Shopify Breaking Changes in version 0.6.0 : The param is_base64 used in function validate from module spylib.utils.hmac is renamed to use_base64 to better convey the meaning of the parameter Breaking Changes in version 0.7.0 : * The webhook features become available from spylib.webhook module as functions instead of from the Token class as methods. * The function spylib.webook_is_valid is now available at spylib.webhook.validate Register Webhooks You can easily register your endpoint to receive webhooks from Shopify using an admin API access token: from spylib import webhook async def register_webhook_with_http_endpoint (): # topics from https://shopify.dev/api/admin-graphql/<API-VERSION>/enums/webhooksubscriptiontopic res = await webhook . create_http ( offline_token =< concrete_offline_token > , topic = 'ORDERS_CREATE' , callback_url = 'https://sometest.com/example' ) print ( f 'Webhook registered with id { res . id } ' ) async def register_webhook_with_event_bridge_endpoint (): # configure AWS Event Bridge https://shopify.dev/apps/webhooks/configuration/eventbridge res = await webhook . create_event_bridge ( offline_token =< concrete_offline_token > , topic = 'ORDERS_CREATE' , arn = '<RESOURCE_NAME>' ) print ( f 'Webhook registered with id { res . id } ' ) async def register_webhook_with_pub_sub_endpoint (): # configure Google Cloud PubSub https://shopify.dev/apps/webhooks/configuration/google-cloud res = await webhook . create_pub_sub ( offline_token =< concrete_offline_token > , topic = 'ORDERS_CREATE' , pub_sub_project = '<PROJECT>' , pub_sub_topic = '<TOPIC>' ) print ( f 'Webhook registered with id { res . id } ' ) Validate Webhooks Shopify webhooks are signed with an HMAC in a header. You can use webhook.validate to verify this signature : from spylib import webhook is_webhook_valid = webhook . validate ( data = 'data' , hmac_header = 'hmac' , api_secret_key = 'API_SECRET_KEY' ) if is_webhook_valid : # do something","title":"Webhooks"},{"location":"webhooks/#webhooks","text":"The webhook functionality can be used to register webhooks and validate that the webhook notifications are from Shopify Breaking Changes in version 0.6.0 : The param is_base64 used in function validate from module spylib.utils.hmac is renamed to use_base64 to better convey the meaning of the parameter Breaking Changes in version 0.7.0 : * The webhook features become available from spylib.webhook module as functions instead of from the Token class as methods. * The function spylib.webook_is_valid is now available at spylib.webhook.validate","title":"Webhooks"},{"location":"webhooks/#register-webhooks","text":"You can easily register your endpoint to receive webhooks from Shopify using an admin API access token: from spylib import webhook async def register_webhook_with_http_endpoint (): # topics from https://shopify.dev/api/admin-graphql/<API-VERSION>/enums/webhooksubscriptiontopic res = await webhook . create_http ( offline_token =< concrete_offline_token > , topic = 'ORDERS_CREATE' , callback_url = 'https://sometest.com/example' ) print ( f 'Webhook registered with id { res . id } ' ) async def register_webhook_with_event_bridge_endpoint (): # configure AWS Event Bridge https://shopify.dev/apps/webhooks/configuration/eventbridge res = await webhook . create_event_bridge ( offline_token =< concrete_offline_token > , topic = 'ORDERS_CREATE' , arn = '<RESOURCE_NAME>' ) print ( f 'Webhook registered with id { res . id } ' ) async def register_webhook_with_pub_sub_endpoint (): # configure Google Cloud PubSub https://shopify.dev/apps/webhooks/configuration/google-cloud res = await webhook . create_pub_sub ( offline_token =< concrete_offline_token > , topic = 'ORDERS_CREATE' , pub_sub_project = '<PROJECT>' , pub_sub_topic = '<TOPIC>' ) print ( f 'Webhook registered with id { res . id } ' )","title":"Register Webhooks"},{"location":"webhooks/#validate-webhooks","text":"Shopify webhooks are signed with an HMAC in a header. You can use webhook.validate to verify this signature : from spylib import webhook is_webhook_valid = webhook . validate ( data = 'data' , hmac_header = 'hmac' , api_secret_key = 'API_SECRET_KEY' ) if is_webhook_valid : # do something","title":"Validate Webhooks"},{"location":"api-docs/","text":"API Overview Modules admin_api constants : These are the text error codes thrown by the GraphQL API. Although some errors exceptions hmac : HMAC (Keyed-Hashing for Message Authentication) module. multipass oauth oauth.exchange_token oauth.models oauth.signature_validation utils utils.domain utils.httpclient utils.misc utils.rest utils.shortuuid webhook webhook.graphql_queries Classes admin_api.OfflineTokenABC : Offline tokens are used for long term access, and do not have a set expiry. admin_api.OnlineTokenABC : Online tokens are used to implement applications that are authenticated with admin_api.PrivateTokenABC : Private token implementation, when we are pulling this from the config file. admin_api.Token : Abstract class for token objects. This should never be extended, as you exceptions.FastAPIImportError : Exception to identify errors when spylip.oauth is accessed without fastapi installed exceptions.ShopifyCallInvalidError : Exception to identify errors that our due to bad data sent by us exceptions.ShopifyError : Exception to identify any Shopify error exceptions.ShopifyExceedingMaxCostError : Exception to identify errors that are due to queries exceeding the max query size exceptions.ShopifyGQLError : Exception to identify any Shopify admin graphql error exceptions.ShopifyGQLUserError : Exception to identify any Shopify admin graphql error caused by the user mistake exceptions.ShopifyThrottledError : Exception to identify errors that are due to rate limit control hmac.HMAC : RFC 2104 HMAC class. Also complies with RFC 4231. models.AssociatedUser : Shopify staff user associated with an online token. models.OfflineTokenModel : Read more about Offline access models.OnlineTokenModel : Read more about Online access httpclient.HTTPClient rest.Method : An enumeration. rest.Request webhook.WebhookCreate : An enumeration. webhook.WebhookResponse webhook.WebhookTopic : An enumeration. Functions exceptions.not_our_fault : Simple function to identify invalid Shopify calls, i.e. our mistake. hmac.calculate_from_components hmac.calculate_from_message hmac.digest : Fast inline implementation of HMAC. hmac.new : Create a new hashing object and return it. hmac.validate multipass.generate_token multipass.generate_url exchange_token.exchange_offline_token : Exchanges the temporary authorization code with Shopify for an offline token. exchange_token.exchange_online_token : Exchanges the temporary authorization code with Shopify for an online token. exchange_token.exchange_token : Exchanges the temporary authorization code with Shopify for a token. signature_validation.validate_signed_query_string : Validates that a query string has been signed by Shopify. domain.domain_to_storename domain.store_domain : Very flexible conversion of a shop's subdomain or complete or incomplete url into a misc.get_unique_id misc.now_epoch shortuuid.int_to_string : Convert a number to a string, using the given alphabet. shortuuid.random : Generate and return a cryptographically-secure short random string webhook.create_event_bridge : Uses graphql to subscribe to a webhook and associated it with webhook.create_http : Uses graphql to subscribe to a webhook and associate it with an HTTP endpoint webhook.create_pub_sub : Uses graphql to subscribe to a webhook and associate it with a Google PubSub endpoint webhook.validate This file was automatically generated via lazydocs .","title":"Overview"},{"location":"api-docs/#api-overview","text":"","title":"API Overview"},{"location":"api-docs/#modules","text":"admin_api constants : These are the text error codes thrown by the GraphQL API. Although some errors exceptions hmac : HMAC (Keyed-Hashing for Message Authentication) module. multipass oauth oauth.exchange_token oauth.models oauth.signature_validation utils utils.domain utils.httpclient utils.misc utils.rest utils.shortuuid webhook webhook.graphql_queries","title":"Modules"},{"location":"api-docs/#classes","text":"admin_api.OfflineTokenABC : Offline tokens are used for long term access, and do not have a set expiry. admin_api.OnlineTokenABC : Online tokens are used to implement applications that are authenticated with admin_api.PrivateTokenABC : Private token implementation, when we are pulling this from the config file. admin_api.Token : Abstract class for token objects. This should never be extended, as you exceptions.FastAPIImportError : Exception to identify errors when spylip.oauth is accessed without fastapi installed exceptions.ShopifyCallInvalidError : Exception to identify errors that our due to bad data sent by us exceptions.ShopifyError : Exception to identify any Shopify error exceptions.ShopifyExceedingMaxCostError : Exception to identify errors that are due to queries exceeding the max query size exceptions.ShopifyGQLError : Exception to identify any Shopify admin graphql error exceptions.ShopifyGQLUserError : Exception to identify any Shopify admin graphql error caused by the user mistake exceptions.ShopifyThrottledError : Exception to identify errors that are due to rate limit control hmac.HMAC : RFC 2104 HMAC class. Also complies with RFC 4231. models.AssociatedUser : Shopify staff user associated with an online token. models.OfflineTokenModel : Read more about Offline access models.OnlineTokenModel : Read more about Online access httpclient.HTTPClient rest.Method : An enumeration. rest.Request webhook.WebhookCreate : An enumeration. webhook.WebhookResponse webhook.WebhookTopic : An enumeration.","title":"Classes"},{"location":"api-docs/#functions","text":"exceptions.not_our_fault : Simple function to identify invalid Shopify calls, i.e. our mistake. hmac.calculate_from_components hmac.calculate_from_message hmac.digest : Fast inline implementation of HMAC. hmac.new : Create a new hashing object and return it. hmac.validate multipass.generate_token multipass.generate_url exchange_token.exchange_offline_token : Exchanges the temporary authorization code with Shopify for an offline token. exchange_token.exchange_online_token : Exchanges the temporary authorization code with Shopify for an online token. exchange_token.exchange_token : Exchanges the temporary authorization code with Shopify for a token. signature_validation.validate_signed_query_string : Validates that a query string has been signed by Shopify. domain.domain_to_storename domain.store_domain : Very flexible conversion of a shop's subdomain or complete or incomplete url into a misc.get_unique_id misc.now_epoch shortuuid.int_to_string : Convert a number to a string, using the given alphabet. shortuuid.random : Generate and return a cryptographically-secure short random string webhook.create_event_bridge : Uses graphql to subscribe to a webhook and associated it with webhook.create_http : Uses graphql to subscribe to a webhook and associate it with an HTTP endpoint webhook.create_pub_sub : Uses graphql to subscribe to a webhook and associate it with a Google PubSub endpoint webhook.validate This file was automatically generated via lazydocs .","title":"Functions"},{"location":"api-docs/admin_api/","text":"module admin_api Global Variables MAX_COST_EXCEEDED_ERROR_CODE OPERATION_NAME_REQUIRED_ERROR_MESSAGE THROTTLED_ERROR_CODE WRONG_OPERATION_NAME_ERROR_MESSAGE class Token Abstract class for token objects. This should never be extended, as you should either be using the OfflineTokenABC or the OnlineTokenABC. property api_url property oauth_url classmethod convert_scope convert_scope ( v ) class OfflineTokenABC Offline tokens are used for long term access, and do not have a set expiry. property api_url property oauth_url classmethod convert_scope convert_scope ( v ) classmethod load load ( store_name : str ) method save save () class OnlineTokenABC Online tokens are used to implement applications that are authenticated with a specific user's credentials. These extend on the original token, adding in a user, its scope and an expiry time. property api_url property oauth_url classmethod convert_scope convert_scope ( v ) classmethod load load ( store_name : str , associated_user : str ) This method handles loading the token. By default this does nothing, therefore the developer should override this. method save save () This method handles saving the token. By default this does nothing, therefore the developer should override this. class PrivateTokenABC Private token implementation, when we are pulling this from the config file. Therefore we do not need the save function for the token class as there is no calls to the OAuth endpoints for shopify. property api_url property oauth_url classmethod convert_scope convert_scope ( v ) classmethod load load ( store_name : str ) This method handles loading the token. By default this does nothing, therefore the developer should override this. This file was automatically generated via lazydocs .","title":"Admin api"},{"location":"api-docs/admin_api/#module-admin_api","text":"","title":"module admin_api"},{"location":"api-docs/admin_api/#global-variables","text":"MAX_COST_EXCEEDED_ERROR_CODE OPERATION_NAME_REQUIRED_ERROR_MESSAGE THROTTLED_ERROR_CODE WRONG_OPERATION_NAME_ERROR_MESSAGE","title":"Global Variables"},{"location":"api-docs/admin_api/#class-token","text":"Abstract class for token objects. This should never be extended, as you should either be using the OfflineTokenABC or the OnlineTokenABC.","title":"class Token"},{"location":"api-docs/admin_api/#property-api_url","text":"","title":"property api_url"},{"location":"api-docs/admin_api/#property-oauth_url","text":"","title":"property oauth_url"},{"location":"api-docs/admin_api/#classmethod-convert_scope","text":"convert_scope ( v )","title":"classmethod convert_scope"},{"location":"api-docs/admin_api/#class-offlinetokenabc","text":"Offline tokens are used for long term access, and do not have a set expiry.","title":"class OfflineTokenABC"},{"location":"api-docs/admin_api/#property-api_url_1","text":"","title":"property api_url"},{"location":"api-docs/admin_api/#property-oauth_url_1","text":"","title":"property oauth_url"},{"location":"api-docs/admin_api/#classmethod-convert_scope_1","text":"convert_scope ( v )","title":"classmethod convert_scope"},{"location":"api-docs/admin_api/#classmethod-load","text":"load ( store_name : str )","title":"classmethod load"},{"location":"api-docs/admin_api/#method-save","text":"save ()","title":"method save"},{"location":"api-docs/admin_api/#class-onlinetokenabc","text":"Online tokens are used to implement applications that are authenticated with a specific user's credentials. These extend on the original token, adding in a user, its scope and an expiry time.","title":"class OnlineTokenABC"},{"location":"api-docs/admin_api/#property-api_url_2","text":"","title":"property api_url"},{"location":"api-docs/admin_api/#property-oauth_url_2","text":"","title":"property oauth_url"},{"location":"api-docs/admin_api/#classmethod-convert_scope_2","text":"convert_scope ( v )","title":"classmethod convert_scope"},{"location":"api-docs/admin_api/#classmethod-load_1","text":"load ( store_name : str , associated_user : str ) This method handles loading the token. By default this does nothing, therefore the developer should override this.","title":"classmethod load"},{"location":"api-docs/admin_api/#method-save_1","text":"save () This method handles saving the token. By default this does nothing, therefore the developer should override this.","title":"method save"},{"location":"api-docs/admin_api/#class-privatetokenabc","text":"Private token implementation, when we are pulling this from the config file. Therefore we do not need the save function for the token class as there is no calls to the OAuth endpoints for shopify.","title":"class PrivateTokenABC"},{"location":"api-docs/admin_api/#property-api_url_3","text":"","title":"property api_url"},{"location":"api-docs/admin_api/#property-oauth_url_3","text":"","title":"property oauth_url"},{"location":"api-docs/admin_api/#classmethod-convert_scope_3","text":"convert_scope ( v )","title":"classmethod convert_scope"},{"location":"api-docs/admin_api/#classmethod-load_2","text":"load ( store_name : str ) This method handles loading the token. By default this does nothing, therefore the developer should override this. This file was automatically generated via lazydocs .","title":"classmethod load"},{"location":"api-docs/constants/","text":"module constants These are the text error codes thrown by the GraphQL API. Although some errors throw a code e.g. \"errors\": [ { \"message\": \"Throttled\", \"extensions\": { \"code\": \"THROTTLED\" } } Not all provide the code parameter. Although you could just handle errors based on the message, this becomes very difficult as some of the messages are very long (see the max_cost_exceeded error output, which is ~350 characters) Global Variables THROTTLED_ERROR_CODE MAX_COST_EXCEEDED_ERROR_CODE OPERATION_NAME_REQUIRED_ERROR_MESSAGE WRONG_OPERATION_NAME_ERROR_MESSAGE UTF8ENCODING This file was automatically generated via lazydocs .","title":"Constants"},{"location":"api-docs/constants/#module-constants","text":"These are the text error codes thrown by the GraphQL API. Although some errors throw a code e.g. \"errors\": [ { \"message\": \"Throttled\", \"extensions\": { \"code\": \"THROTTLED\" } } Not all provide the code parameter. Although you could just handle errors based on the message, this becomes very difficult as some of the messages are very long (see the max_cost_exceeded error output, which is ~350 characters)","title":"module constants"},{"location":"api-docs/constants/#global-variables","text":"THROTTLED_ERROR_CODE MAX_COST_EXCEEDED_ERROR_CODE OPERATION_NAME_REQUIRED_ERROR_MESSAGE WRONG_OPERATION_NAME_ERROR_MESSAGE UTF8ENCODING This file was automatically generated via lazydocs .","title":"Global Variables"},{"location":"api-docs/exceptions/","text":"module exceptions function not_our_fault not_our_fault ( exception : Exception ) Simple function to identify invalid Shopify calls, i.e. our mistake. Probably the only way to make sure we retry for any other exception but those. class ShopifyError Exception to identify any Shopify error class ShopifyGQLError Exception to identify any Shopify admin graphql error class ShopifyGQLUserError Exception to identify any Shopify admin graphql error caused by the user mistake class ShopifyCallInvalidError Exception to identify errors that our due to bad data sent by us These should not be retried class ShopifyThrottledError Exception to identify errors that are due to rate limit control class ShopifyExceedingMaxCostError Exception to identify errors that are due to queries exceeding the max query size class FastAPIImportError Exception to identify errors when spylip.oauth is accessed without fastapi installed This file was automatically generated via lazydocs .","title":"Exceptions"},{"location":"api-docs/exceptions/#module-exceptions","text":"","title":"module exceptions"},{"location":"api-docs/exceptions/#function-not_our_fault","text":"not_our_fault ( exception : Exception ) Simple function to identify invalid Shopify calls, i.e. our mistake. Probably the only way to make sure we retry for any other exception but those.","title":"function not_our_fault"},{"location":"api-docs/exceptions/#class-shopifyerror","text":"Exception to identify any Shopify error","title":"class ShopifyError"},{"location":"api-docs/exceptions/#class-shopifygqlerror","text":"Exception to identify any Shopify admin graphql error","title":"class ShopifyGQLError"},{"location":"api-docs/exceptions/#class-shopifygqlusererror","text":"Exception to identify any Shopify admin graphql error caused by the user mistake","title":"class ShopifyGQLUserError"},{"location":"api-docs/exceptions/#class-shopifycallinvaliderror","text":"Exception to identify errors that our due to bad data sent by us These should not be retried","title":"class ShopifyCallInvalidError"},{"location":"api-docs/exceptions/#class-shopifythrottlederror","text":"Exception to identify errors that are due to rate limit control","title":"class ShopifyThrottledError"},{"location":"api-docs/exceptions/#class-shopifyexceedingmaxcosterror","text":"Exception to identify errors that are due to queries exceeding the max query size","title":"class ShopifyExceedingMaxCostError"},{"location":"api-docs/exceptions/#class-fastapiimporterror","text":"Exception to identify errors when spylip.oauth is accessed without fastapi installed This file was automatically generated via lazydocs .","title":"class FastAPIImportError"},{"location":"api-docs/hmac/","text":"module hmac HMAC (Keyed-Hashing for Message Authentication) module. Implements the HMAC algorithm as described by RFC 2104. Global Variables trans_5C trans_36 digest_size function calculate_from_message calculate_from_message ( secret : str , message : str , use_base64 : bool = False ) \u2192 str function calculate_from_components calculate_from_components ( datetime , path , query_string , body , secret , use_base64 : bool = False ) function validate validate ( secret : str , sent_hmac : str , message : str , use_base64 : bool = False ) function new new ( key , msg = None , digestmod = '' ) Create a new hashing object and return it. key: bytes or buffer, The starting key for the hash. msg: bytes or buffer, Initial input for the hash, or None. digestmod: A hash name suitable for hashlib.new(). OR A hashlib constructor returning a new hash object. OR A module supporting PEP 247. Required as of 3.8, despite its position after the optional msg argument. Passing it as a keyword argument is recommended, though not required for legacy API reasons. You can now feed arbitrary bytes into the object using its update() method, and can ask for the hash value at any time by calling its digest() or hexdigest() methods. function digest digest ( key , msg , digest ) Fast inline implementation of HMAC. key: bytes or buffer, The key for the keyed hash object. msg: bytes or buffer, Input message. digest: A hash name suitable for hashlib.new() for best performance. OR A hashlib constructor returning a new hash object. OR A module supporting PEP 247. class HMAC RFC 2104 HMAC class. Also complies with RFC 4231. This supports the API for Cryptographic Hash Functions (PEP 247). method __init__ __init__ ( key , msg = None , digestmod = '' ) Create a new HMAC object. key: bytes or buffer, key for the keyed hash object. msg: bytes or buffer, Initial input for the hash or None. digestmod: A hash name suitable for hashlib.new(). OR A hashlib constructor returning a new hash object. OR A module supporting PEP 247. Required as of 3.8, despite its position after the optional msg argument. Passing it as a keyword argument is recommended, though not required for legacy API reasons. property digest_cons property inner property name property outer method copy copy () Return a separate copy of this hashing object. An update to this copy won't affect the original object. method digest digest () Return the hash value of this hashing object. This returns the hmac value as bytes. The object is not altered in any way by this function; you can continue updating the object after calling this function. method hexdigest hexdigest () Like digest(), but returns a string of hexadecimal digits instead. method update update ( msg ) Feed data from msg into this hashing object. This file was automatically generated via lazydocs .","title":"Hmac"},{"location":"api-docs/hmac/#module-hmac","text":"HMAC (Keyed-Hashing for Message Authentication) module. Implements the HMAC algorithm as described by RFC 2104.","title":"module hmac"},{"location":"api-docs/hmac/#global-variables","text":"trans_5C trans_36 digest_size","title":"Global Variables"},{"location":"api-docs/hmac/#function-calculate_from_message","text":"calculate_from_message ( secret : str , message : str , use_base64 : bool = False ) \u2192 str","title":"function calculate_from_message"},{"location":"api-docs/hmac/#function-calculate_from_components","text":"calculate_from_components ( datetime , path , query_string , body , secret , use_base64 : bool = False )","title":"function calculate_from_components"},{"location":"api-docs/hmac/#function-validate","text":"validate ( secret : str , sent_hmac : str , message : str , use_base64 : bool = False )","title":"function validate"},{"location":"api-docs/hmac/#function-new","text":"new ( key , msg = None , digestmod = '' ) Create a new hashing object and return it. key: bytes or buffer, The starting key for the hash. msg: bytes or buffer, Initial input for the hash, or None. digestmod: A hash name suitable for hashlib.new(). OR A hashlib constructor returning a new hash object. OR A module supporting PEP 247. Required as of 3.8, despite its position after the optional msg argument. Passing it as a keyword argument is recommended, though not required for legacy API reasons. You can now feed arbitrary bytes into the object using its update() method, and can ask for the hash value at any time by calling its digest() or hexdigest() methods.","title":"function new"},{"location":"api-docs/hmac/#function-digest","text":"digest ( key , msg , digest ) Fast inline implementation of HMAC. key: bytes or buffer, The key for the keyed hash object. msg: bytes or buffer, Input message. digest: A hash name suitable for hashlib.new() for best performance. OR A hashlib constructor returning a new hash object. OR A module supporting PEP 247.","title":"function digest"},{"location":"api-docs/hmac/#class-hmac","text":"RFC 2104 HMAC class. Also complies with RFC 4231. This supports the API for Cryptographic Hash Functions (PEP 247).","title":"class HMAC"},{"location":"api-docs/hmac/#method-__init__","text":"__init__ ( key , msg = None , digestmod = '' ) Create a new HMAC object. key: bytes or buffer, key for the keyed hash object. msg: bytes or buffer, Initial input for the hash or None. digestmod: A hash name suitable for hashlib.new(). OR A hashlib constructor returning a new hash object. OR A module supporting PEP 247. Required as of 3.8, despite its position after the optional msg argument. Passing it as a keyword argument is recommended, though not required for legacy API reasons.","title":"method __init__"},{"location":"api-docs/hmac/#property-digest_cons","text":"","title":"property digest_cons"},{"location":"api-docs/hmac/#property-inner","text":"","title":"property inner"},{"location":"api-docs/hmac/#property-name","text":"","title":"property name"},{"location":"api-docs/hmac/#property-outer","text":"","title":"property outer"},{"location":"api-docs/hmac/#method-copy","text":"copy () Return a separate copy of this hashing object. An update to this copy won't affect the original object.","title":"method copy"},{"location":"api-docs/hmac/#method-digest","text":"digest () Return the hash value of this hashing object. This returns the hmac value as bytes. The object is not altered in any way by this function; you can continue updating the object after calling this function.","title":"method digest"},{"location":"api-docs/hmac/#method-hexdigest","text":"hexdigest () Like digest(), but returns a string of hexadecimal digits instead.","title":"method hexdigest"},{"location":"api-docs/hmac/#method-update","text":"update ( msg ) Feed data from msg into this hashing object. This file was automatically generated via lazydocs .","title":"method update"},{"location":"api-docs/multipass/","text":"module multipass function generate_token generate_token ( secret : str , customer_data : Dict [ str , Any ]) \u2192 bytes function generate_url generate_url ( secret : str , customer_data : Dict [ str , Any ], store_url ) \u2192 str This file was automatically generated via lazydocs .","title":"Multipass"},{"location":"api-docs/multipass/#module-multipass","text":"","title":"module multipass"},{"location":"api-docs/multipass/#function-generate_token","text":"generate_token ( secret : str , customer_data : Dict [ str , Any ]) \u2192 bytes","title":"function generate_token"},{"location":"api-docs/multipass/#function-generate_url","text":"generate_url ( secret : str , customer_data : Dict [ str , Any ], store_url ) \u2192 str This file was automatically generated via lazydocs .","title":"function generate_url"},{"location":"api-docs/oauth.exchange_token/","text":"module oauth.exchange_token function exchange_token exchange_token ( shop : str , code : str , api_key : str , api_secret_key : str ) \u2192 Union [ OnlineTokenModel , OfflineTokenModel ] Exchanges the temporary authorization code with Shopify for a token. All prior security checks must already have been completed. Args: shop (str): The name of the merchant's shop. example.myshopify.com code (str): The authorization code provided in the redirect. api_key (str): The API key for the app, as defined in the Shopify Partner Dashboard. api_secret_key (str): The API secret key for the app, as defined in the Shopify Partner Dashboard. Returns: Union[OnlineTokenModel, OfflineTokenModel] : Validated token response. Will differ depending upon the requested access mode. function exchange_offline_token exchange_offline_token ( shop : str , code : str , api_key : str , api_secret_key : str ) \u2192 OfflineTokenModel Exchanges the temporary authorization code with Shopify for an offline token. Can be used instead of exchange_token when you know by some mechanism it will only be an offline token. All prior security checks must already have been completed. Args: shop (str): The name of the merchant's shop. example.myshopify.com code (str): The authorization code provided in the redirect. api_key (str): The API key for the app, as defined in the Shopify Partner Dashboard. api_secret_key (str): The API secret key for the app, as defined in the Shopify Partner Dashboard. Returns: OfflineTokenModel : [Validated offline token response.]https://shopify.dev/apps/auth/oauth/access-modes#offline-access function exchange_online_token exchange_online_token ( shop : str , code : str , api_key : str , api_secret_key : str ) \u2192 OnlineTokenModel Exchanges the temporary authorization code with Shopify for an online token. Can be used instead of exchange_token when you know by some mechanism it will only be an online token. All prior security checks must already have been completed. Args: shop (str): The name of the merchant's shop. example.myshopify.com code (str): The authorization code provided in the redirect. api_key (str): The API key for the app, as defined in the Shopify Partner Dashboard. api_secret_key (str): The API secret key for the app, as defined in the Shopify Partner Dashboard. Returns: OnlineTokenModel : [Validated online token response.]https://shopify.dev/apps/auth/oauth/access-modes#online-access This file was automatically generated via lazydocs .","title":"Oauth.exchange token"},{"location":"api-docs/oauth.exchange_token/#module-oauthexchange_token","text":"","title":"module oauth.exchange_token"},{"location":"api-docs/oauth.exchange_token/#function-exchange_token","text":"exchange_token ( shop : str , code : str , api_key : str , api_secret_key : str ) \u2192 Union [ OnlineTokenModel , OfflineTokenModel ] Exchanges the temporary authorization code with Shopify for a token. All prior security checks must already have been completed. Args: shop (str): The name of the merchant's shop. example.myshopify.com code (str): The authorization code provided in the redirect. api_key (str): The API key for the app, as defined in the Shopify Partner Dashboard. api_secret_key (str): The API secret key for the app, as defined in the Shopify Partner Dashboard. Returns: Union[OnlineTokenModel, OfflineTokenModel] : Validated token response. Will differ depending upon the requested access mode.","title":"function exchange_token"},{"location":"api-docs/oauth.exchange_token/#function-exchange_offline_token","text":"exchange_offline_token ( shop : str , code : str , api_key : str , api_secret_key : str ) \u2192 OfflineTokenModel Exchanges the temporary authorization code with Shopify for an offline token. Can be used instead of exchange_token when you know by some mechanism it will only be an offline token. All prior security checks must already have been completed. Args: shop (str): The name of the merchant's shop. example.myshopify.com code (str): The authorization code provided in the redirect. api_key (str): The API key for the app, as defined in the Shopify Partner Dashboard. api_secret_key (str): The API secret key for the app, as defined in the Shopify Partner Dashboard. Returns: OfflineTokenModel : [Validated offline token response.]https://shopify.dev/apps/auth/oauth/access-modes#offline-access","title":"function exchange_offline_token"},{"location":"api-docs/oauth.exchange_token/#function-exchange_online_token","text":"exchange_online_token ( shop : str , code : str , api_key : str , api_secret_key : str ) \u2192 OnlineTokenModel Exchanges the temporary authorization code with Shopify for an online token. Can be used instead of exchange_token when you know by some mechanism it will only be an online token. All prior security checks must already have been completed. Args: shop (str): The name of the merchant's shop. example.myshopify.com code (str): The authorization code provided in the redirect. api_key (str): The API key for the app, as defined in the Shopify Partner Dashboard. api_secret_key (str): The API secret key for the app, as defined in the Shopify Partner Dashboard. Returns: OnlineTokenModel : [Validated online token response.]https://shopify.dev/apps/auth/oauth/access-modes#online-access This file was automatically generated via lazydocs .","title":"function exchange_online_token"},{"location":"api-docs/oauth/","text":"module oauth Global Variables models signature_validation This file was automatically generated via lazydocs .","title":"Oauth"},{"location":"api-docs/oauth/#module-oauth","text":"","title":"module oauth"},{"location":"api-docs/oauth/#global-variables","text":"models signature_validation This file was automatically generated via lazydocs .","title":"Global Variables"},{"location":"api-docs/oauth.models/","text":"module oauth.models class OfflineTokenModel Read more about Offline access class AssociatedUser Shopify staff user associated with an online token. class OnlineTokenModel Read more about Online access This file was automatically generated via lazydocs .","title":"Oauth.models"},{"location":"api-docs/oauth.models/#module-oauthmodels","text":"","title":"module oauth.models"},{"location":"api-docs/oauth.models/#class-offlinetokenmodel","text":"Read more about Offline access","title":"class OfflineTokenModel"},{"location":"api-docs/oauth.models/#class-associateduser","text":"Shopify staff user associated with an online token.","title":"class AssociatedUser"},{"location":"api-docs/oauth.models/#class-onlinetokenmodel","text":"Read more about Online access This file was automatically generated via lazydocs .","title":"class OnlineTokenModel"},{"location":"api-docs/oauth.signature_validation/","text":"module oauth.signature_validation function validate_signed_query_string validate_signed_query_string ( query_string : str , api_secret_key : str ) Validates that a query string has been signed by Shopify. Implements the parsing algorithm defined by Shopify here . Including the special case ids parameter parsing Args: query_string : A valid query string. hmac=123&test=456 api_secret_key : The api secret key from Shopify partners. Raises: Exception : ValueError This file was automatically generated via lazydocs .","title":"Oauth.signature validation"},{"location":"api-docs/oauth.signature_validation/#module-oauthsignature_validation","text":"","title":"module oauth.signature_validation"},{"location":"api-docs/oauth.signature_validation/#function-validate_signed_query_string","text":"validate_signed_query_string ( query_string : str , api_secret_key : str ) Validates that a query string has been signed by Shopify. Implements the parsing algorithm defined by Shopify here . Including the special case ids parameter parsing Args: query_string : A valid query string. hmac=123&test=456 api_secret_key : The api secret key from Shopify partners. Raises: Exception : ValueError This file was automatically generated via lazydocs .","title":"function validate_signed_query_string"},{"location":"api-docs/utils.domain/","text":"module utils.domain function domain_to_storename domain_to_storename ( domain : str ) \u2192 str function store_domain store_domain ( shop : str ) \u2192 str Very flexible conversion of a shop's subdomain or complete or incomplete url into a complete url This file was automatically generated via lazydocs .","title":"Utils.domain"},{"location":"api-docs/utils.domain/#module-utilsdomain","text":"","title":"module utils.domain"},{"location":"api-docs/utils.domain/#function-domain_to_storename","text":"domain_to_storename ( domain : str ) \u2192 str","title":"function domain_to_storename"},{"location":"api-docs/utils.domain/#function-store_domain","text":"store_domain ( shop : str ) \u2192 str Very flexible conversion of a shop's subdomain or complete or incomplete url into a complete url This file was automatically generated via lazydocs .","title":"function store_domain"},{"location":"api-docs/utils.httpclient/","text":"module utils.httpclient class HTTPClient property auth Authentication class used when none is passed at the request-level. See also Authentication . property base_url Base URL to use when sending requests with relative URLs. property cookies Cookie values to include when sending requests. property event_hooks property headers HTTP headers to include when sending requests. property is_closed Check if the client being closed property params Query parameters to include in the URL when sending requests. property timeout property trust_env classmethod close close () This file was automatically generated via lazydocs .","title":"Utils.httpclient"},{"location":"api-docs/utils.httpclient/#module-utilshttpclient","text":"","title":"module utils.httpclient"},{"location":"api-docs/utils.httpclient/#class-httpclient","text":"","title":"class HTTPClient"},{"location":"api-docs/utils.httpclient/#property-auth","text":"Authentication class used when none is passed at the request-level. See also Authentication .","title":"property auth"},{"location":"api-docs/utils.httpclient/#property-base_url","text":"Base URL to use when sending requests with relative URLs.","title":"property base_url"},{"location":"api-docs/utils.httpclient/#property-cookies","text":"Cookie values to include when sending requests.","title":"property cookies"},{"location":"api-docs/utils.httpclient/#property-event_hooks","text":"","title":"property event_hooks"},{"location":"api-docs/utils.httpclient/#property-headers","text":"HTTP headers to include when sending requests.","title":"property headers"},{"location":"api-docs/utils.httpclient/#property-is_closed","text":"Check if the client being closed","title":"property is_closed"},{"location":"api-docs/utils.httpclient/#property-params","text":"Query parameters to include in the URL when sending requests.","title":"property params"},{"location":"api-docs/utils.httpclient/#property-timeout","text":"","title":"property timeout"},{"location":"api-docs/utils.httpclient/#property-trust_env","text":"","title":"property trust_env"},{"location":"api-docs/utils.httpclient/#classmethod-close","text":"close () This file was automatically generated via lazydocs .","title":"classmethod close"},{"location":"api-docs/utils/","text":"module utils Global Variables domain httpclient shortuuid : # Code copied over from shortuuid package: https://github.com/skorokithakis/shortuuid/blob/v1.0.8/shortuuid/main.py misc jwtoken rest This file was automatically generated via lazydocs .","title":"Utils"},{"location":"api-docs/utils/#module-utils","text":"","title":"module utils"},{"location":"api-docs/utils/#global-variables","text":"domain httpclient shortuuid : # Code copied over from shortuuid package:","title":"Global Variables"},{"location":"api-docs/utils/#httpsgithubcomskorokithakisshortuuidblobv108shortuuidmainpy","text":"misc jwtoken rest This file was automatically generated via lazydocs .","title":"https://github.com/skorokithakis/shortuuid/blob/v1.0.8/shortuuid/main.py"},{"location":"api-docs/utils.misc/","text":"module utils.misc function now_epoch now_epoch () \u2192 int function get_unique_id get_unique_id () \u2192 str This file was automatically generated via lazydocs .","title":"Utils.misc"},{"location":"api-docs/utils.misc/#module-utilsmisc","text":"","title":"module utils.misc"},{"location":"api-docs/utils.misc/#function-now_epoch","text":"now_epoch () \u2192 int","title":"function now_epoch"},{"location":"api-docs/utils.misc/#function-get_unique_id","text":"get_unique_id () \u2192 str This file was automatically generated via lazydocs .","title":"function get_unique_id"},{"location":"api-docs/utils.rest/","text":"module utils.rest Global Variables GET POST PUT DELETE class Method An enumeration. class Request This file was automatically generated via lazydocs .","title":"Utils.rest"},{"location":"api-docs/utils.rest/#module-utilsrest","text":"","title":"module utils.rest"},{"location":"api-docs/utils.rest/#global-variables","text":"GET POST PUT DELETE","title":"Global Variables"},{"location":"api-docs/utils.rest/#class-method","text":"An enumeration.","title":"class Method"},{"location":"api-docs/utils.rest/#class-request","text":"This file was automatically generated via lazydocs .","title":"class Request"},{"location":"api-docs/utils.shortuuid/","text":"module utils.shortuuid Global Variables ALPHABET function random random ( length ) Generate and return a cryptographically-secure short random string of the specified length. function int_to_string int_to_string ( number , alphabet , padding = None ) Convert a number to a string, using the given alphabet. The output has the most significant digit first. This file was automatically generated via lazydocs .","title":"Utils.shortuuid"},{"location":"api-docs/utils.shortuuid/#module-utilsshortuuid","text":"","title":"module utils.shortuuid"},{"location":"api-docs/utils.shortuuid/#global-variables","text":"ALPHABET","title":"Global Variables"},{"location":"api-docs/utils.shortuuid/#function-random","text":"random ( length ) Generate and return a cryptographically-secure short random string of the specified length.","title":"function random"},{"location":"api-docs/utils.shortuuid/#function-int_to_string","text":"int_to_string ( number , alphabet , padding = None ) Convert a number to a string, using the given alphabet. The output has the most significant digit first. This file was automatically generated via lazydocs .","title":"function int_to_string"},{"location":"api-docs/webhook.graphql_queries/","text":"module webhook.graphql_queries Global Variables WEBHOOK_CREATE_GQL This file was automatically generated via lazydocs .","title":"Webhook.graphql queries"},{"location":"api-docs/webhook.graphql_queries/#module-webhookgraphql_queries","text":"","title":"module webhook.graphql_queries"},{"location":"api-docs/webhook.graphql_queries/#global-variables","text":"WEBHOOK_CREATE_GQL This file was automatically generated via lazydocs .","title":"Global Variables"},{"location":"api-docs/webhook/","text":"module webhook Global Variables UTF8ENCODING WEBHOOK_CREATE_GQL function validate validate ( data : Union [ str , bytes ], hmac_header : str , api_secret_key : str ) \u2192 bool function create_http create_http ( offline_token : OfflineTokenABC , topic : Union [ WebhookTopic , str ], callback_url : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to subscribe to a webhook and associate it with an HTTP endpoint function create_event_bridge create_event_bridge ( offline_token : OfflineTokenABC , topic : Union [ WebhookTopic , str ], arn : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to subscribe to a webhook and associated it with and AWS Event Bridge with ARN (Amazon Resource Name) function create_pub_sub create_pub_sub ( offline_token : OfflineTokenABC , topic : Union [ WebhookTopic , str ], pub_sub_project : str , pub_sub_topic : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to subscribe to a webhook and associate it with a Google PubSub endpoint class WebhookTopic An enumeration. class WebhookResponse class WebhookCreate An enumeration. This file was automatically generated via lazydocs .","title":"Webhook"},{"location":"api-docs/webhook/#module-webhook","text":"","title":"module webhook"},{"location":"api-docs/webhook/#global-variables","text":"UTF8ENCODING WEBHOOK_CREATE_GQL","title":"Global Variables"},{"location":"api-docs/webhook/#function-validate","text":"validate ( data : Union [ str , bytes ], hmac_header : str , api_secret_key : str ) \u2192 bool","title":"function validate"},{"location":"api-docs/webhook/#function-create_http","text":"create_http ( offline_token : OfflineTokenABC , topic : Union [ WebhookTopic , str ], callback_url : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to subscribe to a webhook and associate it with an HTTP endpoint","title":"function create_http"},{"location":"api-docs/webhook/#function-create_event_bridge","text":"create_event_bridge ( offline_token : OfflineTokenABC , topic : Union [ WebhookTopic , str ], arn : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to subscribe to a webhook and associated it with and AWS Event Bridge with ARN (Amazon Resource Name)","title":"function create_event_bridge"},{"location":"api-docs/webhook/#function-create_pub_sub","text":"create_pub_sub ( offline_token : OfflineTokenABC , topic : Union [ WebhookTopic , str ], pub_sub_project : str , pub_sub_topic : str , include_fields : Optional [ List [ str ]] = None , metafield_namespaces : Optional [ List [ str ]] = None , private_metafield_namespaces : Optional [ List [ str ]] = None ) \u2192 WebhookResponse Uses graphql to subscribe to a webhook and associate it with a Google PubSub endpoint","title":"function create_pub_sub"},{"location":"api-docs/webhook/#class-webhooktopic","text":"An enumeration.","title":"class WebhookTopic"},{"location":"api-docs/webhook/#class-webhookresponse","text":"","title":"class WebhookResponse"},{"location":"api-docs/webhook/#class-webhookcreate","text":"An enumeration. This file was automatically generated via lazydocs .","title":"class WebhookCreate"}]}